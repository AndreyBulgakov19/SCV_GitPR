![Logo](git.jpeg)

## Работа с GIT

## 1. Проверка наличия установленного GIT
В терминале выполнить команду `git --version`.
Если git установлен появится сообщение с информацией о версии программы, иначе будет сообщение об ошибке.

## 2. Установка GIT.
Загружаем последнюю версию Git с [сайта](https://git-scm.com/downloads).
Устанавливаем настройки по умолчанию.

## 3. Настройка GIT.
При первом использовании Git необходимо представиться.
Для этого нужно ввести в терминале 2 команды:
```
git config --global user.name «Ваше имя английскими буквами»
git config --global user.email ваша почта@example.com
```
## 4. Инициализация репозитория.
Инициализация или создание репозитория производится командой `git init`.
При инициализации репозитория в директории проекта будет создана скрытая поддиректория .git, которая содержит различные сущности git и информацию о репозитории. 
В git есть три зоны видимости файлов:
*Первая зона видимости: рабочая директория (Working directory) — это директория, содержащая файлы проекта. Просмотреть все файлы в директории можно командой `ls -la`.*

*Вторая зона видимости: индекс (Staging area) — это виртуальная зона, где фиксируются изменения внесенные в файлы проекта перед тем, как они будут сохранены (закоммичены). Посмотреть, какие изменения содержатся в индексе можно командой `git status`.*

*Третья зона видимости: репозиторий (Repository) — это сохраненные изменения, попавшие в директорию .git после коммита. В этой зоне содержатся различные git-объекты. Напрямую с ними взаимодействовать нельзя.*

## 5. Запись изменений в репозиторий.
Добавим кое-какие изменения к нашим разделам в инстукции. Изменим содержимое файла.
Проверим состояние рабочего каталога командой `git status`
Первое, что нужно заметить, это то, что git знает, что файл hello.html был изменен, но при этом эти изменения еще не зафиксированы в репозитории.

Затем обратите внимание на то, что сообщение о состоянии дает вам подсказку о том, что нужно делать дальше. Если вы хотите добавить эти изменения в репозиторий, используйте команду `git add`. В противном случае используйте команду `git сheckout` для отмены изменений.

## 6. Просмотр истории коммитов.
После того, как вы создали несколько коммитов или же клонировали репозиторий с уже существующей историей коммитов, вероятно вам понадобится возможность посмотреть что было сделано — историю коммитов. Одним из основных и наиболее мощных инструментов для этого является команда `git log`.

По умолчанию (без аргументов) `git log` перечисляет коммиты, сделанные в репозитории в обратном к хронологическому порядке — последние коммиты находятся вверху. 

Есть много различных вариантов и комбинаций параметров **log**, посмотрим некоторые из них:

***`git log -p`, расширенный вывод истории (Выводит то же, что и git log, но еще и с изменениями в файлах)***

***`git log --oneline`, короткая запись (Вывод коммитов в одну строку. Показывает только хэш коммита и commit message)***

***`git log --stat --graph`, история в виде дерева (Выводит коммиты в виде дерева, в командной строке псевдографикой. Плюс выводит список измененных файлов).***

## 7. Перемещение между сохранениями (коммитами).

Git позволяет не только просматривать историю. Еще мы можем перемещаться по истории, загружая в рабочую директорию состояние кода на момент выполнения любого коммита. В этом уроке мы изучим, как перемещаться по истории с помощью команды `git checkout`.

Для начала воспользуемся
командой `git log`:

Переключимся на момент, когда был выполнен коммит, Для этого используем команду `git checkout` <хеш коммита>:
Выполните команду выше и изучите рабочую директорию. Обратите внимание, что хеш вашего коммита может отличаться, и мы снова можем вернуться на последний коммит следующей командой: `git checkout master`.
Переключение по коммитам отражается только на содержимом рабочей директории. Больше нигде не видно, где мы находимся. Из-за этого многие забывают, где они находятся. Они начинают работать и очень удивляются, когда не получается выполнить коммит.
Самый простой способ узнать место нахождения — вызвать команду `git branch`. Такой способ проверки текущего местоположения требует постоянного внимания. Нужно не забывать его использовать. 

## 8. Игнорирование файлов.

Для того чтобы исключить из отслеживания в репозитории определенный файл или папки необходимо создать там файл `.gitignore` и записать в него их названия или шаблоны, соответствующие таким файлам или папкам.

## 9. Создание веток в GIT.
По умолчанию имя основной ветки в Git - **master**.
Создать ветку можно командой:
```
git branch <имя новой ветки>
```
Список веток в репозитории можно посмотреть с помощью команды: `git-branch`.

Текущая ветка будет помечена звездочкой: **\*master**

Создадим новую ветвь `new` командой: 
`git branch new`. Добавим в нее описание файла и сделаем коммит - `git commit -am "Добавление описания"`
Если у нас в коммите в сообщении есть опечатка, мы можем поменять подпись к последнему коммиту при помощи команды `git commit --amend`.

## 10. Слияние веток и разрешение конфликтов.
Мастер (**master**)- это основная ветка проекта, в которую заливается только рабочий проверенный код. Новый функционал в конце концов оказывается в мастере. 

**Merge** - Это перенос кода из одной ветки в другую. Например, когда мы заканчиваем работу над веткой, например, сделали новый функционал, мы сливаем ее в мастер. В мастере код проверяется еще раз и выкладывается на боевой сервер.

Сливать друг в друга можно любые ветки. Технически, с точки зрения `git` нет никакой разницы, сливается ветка с новым функционалом в мастер или наоборот. Для нас мастер - это основная ветка разработки, а для `git` это просто ветка.

Слияние выполняется после завершения работы над своей веткой при помощи команды `git merge`. Чтобы "слить" ветку в мастер, нужно сначала перейти в мастер, а затем выполнить команду `git merge branch_name`.


После запуска выполнения слияния веток коммитов, если возник конфликт слияния, то слияние будет приостановлено до разрешения конфликта. Файл, в котором возник конфликт слияния, можно открыть в обычном окне-вкладке для редактирования. Это можно сделать хоть из вкладки «Проводник» (_по-английски «Explorer», сочетание клавиш «Ctrl+Shift+E»_), хоть из вкладки «Система управления версиями» (_по-английски «Source Control», сочетание клавиш «Ctrl+Shift+G»_), боковой панели (если этот файл уже не открыт в окне-вкладке редактора).

Начало места конфликта в файле обозначено так:
```
<<<<<<< HEAD (Current Change)
```

Окончание места конфликта в файле обозначено так:
```
>>>>>>> new-branch (Incoming Change)
```
Между этими обозначениями показаны два варианта кода в файле: 
1) из текущей ветки (на которую указывает указатель «HEAD», у меня эта ветка называется «master».  
2) из ветки с названием «new-branch», из которой я вливаю изменения в ветку «master». 
Для завершения слияния веток программист должен выбрать один из этих вариантов кода. В принципе, это можно сделать вручную, но в редакторе _«VS Code»_ имеется функция, которая называется _«CodeLens»_.

В данном случае функция «CodeLens» вывела над местом конфликта четыре подсказки в виде ссылок, на которые можно нажимать:
```
– Accept Current Change [выбрать вариант текущей ветки];
– Accept Incoming Change [выбрать вариант ветки, из которой идет слияние];
– Accept Both Changes [оба варианта останутся в файле друг под другом];
– Compare Changes [открывает дополнительное окно-вкладку со сравнением двух версий файла, похожее на редактор разниц].

```

## 11. Удаление веток.
Обычно репозиторий `git` имеет разные ветки. Это хороший способ работать над различными функциями и исправлениями, изолируя новый код от основной кодовой базы. В репозиториях часто есть главная ветка для основной базы кода, и разработчики создают другие ветки с именами по своему выбору для работы над различными функциями или исправлениями.

_Git_ не позволит вам удалить ветку, над которой вы в данный момент работаете. Поэтому вы должны убедиться, что выполнили проверку на ветку, которую вы НЕ удаляете. Для этого используйте команду:

`git checkout branch-name`

Теперь, чтобы удалить тестовую ветку локально, мы используем команду :

`git branch -d branch-name`

__Примечание:__ Опция *-d* удалит ветку, только если она уже была удалена и объединена с удаленной веткой. Если вы хотите принудительно удалить ветку, вам придется вместо этого использовать опцию *-D* .  
Флаг *-D* является синонимом _–delete –force_. Это принудительно удалит ветку, даже если она не была удалена или объединена с удаленным. полная команда:

`git branch -D branch-name`\
С помощью этого мы можем успешно удалить локальную ветку.

Вы не можете использовать команду `git branch` для удаления удаленной ветки. Вместо этого вы должны использовать команду `git push` с флагом _–delete_, за которой следует название ветки, которую мы хотим удалить.

## 12. Работа с удаленными репозиториями.

Удаленный репозиторий – это версии вашего проекта, сохраненные на удаленном сервере. Доступ к репозиторию на таком сервере может осуществляться по интернету или по локальной сети.

Чтобы загрузить что-нибудь в удаленный репозиторий, сначала нужно к нему подключиться. Регистрация и установка может занять время, но все подобные сервисы предоставляют хорошую документацию.
Чтобы связать наш локальный репозиторий с репозиторием на GitHub, выполним следующую команду в терминале. Обратите внимание, что нужно обязательно изменить URI репозитория на свой. `git remote add origin <название удаленного репозитория> <ссылка на удаленный репозиторий>`\
Когда необходимо переслать наш локальный коммит на сервер, этот процесс происходит каждый раз, когда мы хотим обновить данные в удаленном репозитории.
Команда, предназначенная для этого - `git push`.  Чтобы автоматически получить изменения из удалённой ветки и слить их со своей текущей нужно использовать комманду - `git pull`.

Клонировать существующий удаленный репозиторий можно с использованием команды `git clone <ссылка на удаленный репозиторий>`. Обязательно создать новую ветку командой `git switch -c (название ветки)` затем в данной ветке создать файл и в него нужно внести изменения в сам проект при помощи коммитов.
```
git add .
git commit -m "My commit"
```
После этого небходимо отправить изменения в копию репозитория на Github с использованием команды `git push origin <название ветки>`.
Теперь изменения находятся в копии репозитория на GitHub в ветке <название ветки>.
Далее нужно зайти на страницу копии репозитория и нажимать на кнопку *"Compare & Pull Request"*. После проверки изменений нужно нажать на кнопку *"Create pull request"*. Далее открывается страница с *Pull Request*, где можно посмотреть информацию об изменениях, его состоянии, также его можно прокомментировать или закрыть. Также на странице изначального репозитория можно перейти на вкладку *"Pull requstes"* и увидеть все запросы на внесение изменений.



![Logo](thanks.jpg)