![Logo](Git-Logo-2Color.png)
# ***Работа с Git***

## 1. Общее

**Git** — система контроля версий (файлов). Что-то вроде возможности сохраняться в компьютерных играх (в Git эквивалент игрового сохранения — коммит). **Важно**: добавление файлов к «сохранению» двухступенчатое: сначала добавляем файл в индекс (`git add`), потом «сохраняем» (`git commit`).

*Любой файл в директории существующего репозитория может находиться или не находиться под версионным контролем (отслеживаемые и неотслеживаемые).*

*Отслеживаемые файлы могут быть в 3-х состояниях: неизменённые, изменённые, проиндексированные (готовые к коммиту).*

## 2. Проверка наличия установленного Git

В терминале выполнить команду `git --version` 

Если Git установлен, появится сообщение с информацией о версии программы, иначе будет сообщение об ошибке. 

## 3. Установка Git

- *Для Windows загружаем последнюю версию Git с [сайта](https://git-scm.com/downloads). Устанавливаем с настройками по умолчанию*.
- *Для Mac OS открываем терминал и пишем*:

``` bash
#Если установлен Homebrew

brew install git            
#Если нет, то вводим эту команду:

git --version
#После этого появится окно, где предложит установить Command Line Tools (CLT).

#Соглашаемся и ждем установки. Вместе с CLT установиться и git
```
- *Для Linux открываем терминал и вводим следующую команду*:
``` bash

# Debian или Ubuntu
sudo apt install git

# CentOS
sudo yum install git
```

## 4. Настройка Git

- *Перед началом работы нужно выполнить некоторые настройки*:

```
git config --global user.name "Your Name" # указать имя, которым будут подписаны коммиты
git config --global user.email "e@w.com"  # указать электропочту, которая будет в описании коммитера
```

- *Если вы в Windows*:

```
git config --global core.autocrlf true # включить преобразование окончаний строк из CRLF в LF
```

## 5. Как найти помощь по Git

В GIT встроена подробная справка по всем командам - для этого используйте команду `git help`.

Если нужна информация по всем коммандам, то используйте опцию `-a`:

```bash
git help -a
```

Если нужна информация по всем руководствам, то используйте опцию `-g`:

```bash
git help -g
```

<br>

Также по каждой команде можно получить полную справку используя опцию `--help`:

```bash
git <комманда> --help
```

или короткую справку используя опцию `-h`:

```bash
git <комманда> -h
```

## 6. Начало работы

### 6.1. Как создать репозиторий?

Для создание нового репозитория используется команда `git init`.

Либо можно скопировать уже существующий репозиторий с помощью команды `git clone` и одновременно задать ему новое имя:

``` bash
git clone <url> <новое_имя>
```

В GIT предусмотрено несколько вариантов транспортных протоколов (URL):
  1. https://
  2. git://
  3. user@server:path/to/repo.git

### 6.2. Как добавить файлы в индекс?

Чтобы **добавить файл в индекс**, используется комманда `git add`, а чтобы *добавить все объекты* в папке - используется `.` *точка* или опция `-A`:

```bash
git add .
git add -A
```
### 6.3. Как исключить ненужные файлы?

Чтобы GIT игнорировал при индексации файлы, которые не должны попасть в коммит, используется специальный файл **.gitignore**, который создается в каталоге репозитория.

В данном файле используются для удобства шаблоны и спецсимволы, которые интерпритируются GIT следующим образом:

+ `#` = информация не читается GIT, используется для комментариев,
  + пустая строка в **.gitignore** тоже не буде читаться;
+ `!` = создает исключение из .gitignore, файл будет индексирован;
+ `?` = обозначает один символ в названии файла;
+ `*` = ноль и более символов;
+ `[az]` = игнорирование любого символов в скобках;
+ `[0-9]` = игнорирование любого символа из интервала;
+ `/` = разделитель каталогов;
+ `/**/` = игнорирование любого количества подкаталогов;
+ `\` = используется для экранирования спецсимволов;
+ `.расширение_файла` например - `.jpg` или `.png` = игнорирование файлов с заданным расширением;
+ `имя_файла.py` = игнорирование выбранного файла.

### 6.4. Как сделать первый коммит?

Чтобы сделать коммит проиндексированных файлов, используется комманда `git commit`, а чтобы указать комментарий к коммиту используется опция `-m`:

```bash
git commit -m "first commit"
```

``` bash
git commit -a -m "second of commit" 
# проиндексировать отслеживаемые файлы (ТОЛЬКО отслеживаемые, но НЕ новые файлы) и закоммитить, добавить сообщение
```

### 6.5. Как переключяться между коммитами?

Чтобы переключиться на коммит с конкретным хешем используется комманда:
``` bash
git checkout b9533bb
````
Чтобы переключиться на коммит, на который указывает master:

```
git checkout master
```

### 6.6. Как посмотреть историю коммитов?


``` bash
git log master             # показать коммиты в указанной ветке
```
Выход из длинного лога вывода: `q`.



## 7. Управление в Git

### 7.1. Как проверить статус файлов?

Чтобы проверить статус файлов, используется комманда `git status`, с помощью которой можно узнать в каком статусе файл:

+ `Untracked` = файл не индексирован
+ `Unmodified` = файл индексирован, но не изменен
+ `Modified` = файл индексирован и изменен
+ `Staged` = идексированный файл готов к коммиту

Чтобы просмотреть в упрощенном виде статус файлов, используется опция `-s` или `--short`:

```bash
git status -s
```

<br>

На экран выводится два столбца со следующим условными обозначениями:
<table>
    <tr>
        <th>Символ слева</th>
        <th>Символ справа</th>
        <th>Статус</th>
    </tr>
    <tr>
        <td>?</td>
        <td>?</td>
        <td>не идексирован</td>
    </tr>
    <tr>
        <td>A</td>
        <td>-</td>
        <td>индексирован</td>
    </tr>
    <tr>
        <td>M</td>
        <td>-</td>
        <td>модифицирован</td>
    <tr>
        <td>-</td>
        <td>М</td>
        <td>модифицирован, но не индексирован</td>
    </tr>
    </tr>
    <tr>
        <td>M</td>
        <td>М</td>
        <td>модифицирован, индексирован и снова модифицирован</td>
    </tr>
</table>

---

Чтобы узнать более подробно об изменениях файлов и их статутуса, используется комманда `git diff`.

Чтобы узнать о том, какие файлы проиндексированы и войдут в следующий коммиит, используется опция `--staged` или `--cached`:

```bash
git diff --staged
git diff --cached
```

### 7.2. Как сравнить коммиты?

Чтобы **показать и сравнить коммиты**, используется комманда `git log`.

Чтобы **увидеть детальный изменения**, привнесенные коммитом, используется опция `-p` или `--patch`:

```bash
git log -p
git log --patch
```
<br>

Чтобы увидеть **сокращенный варинт изменений**, используется опция `--stat`:

```bash
git log --stat
```
<br>

Для просмотра отдельного коммита используктся комманда `git show`.

### 7.3. Как переимновать файл?

Чтобы переименовать файл, используется комманда `git mv`:

```bash
git rm <файл_1> <файл_2>
```

### 7.4. Как заменить коммит?

Чтобы заменить коммит внеся в него поправки, используется кооманда `git commit --amend`:

```bash
git commit --amend
```

## 8. Работа с ветками в Git
Для создание веток используется комманда `git branch namebranch`.
По умолчанию имя основной ветки в Git - master 
### 8.1. Просмотр всех доступных веток
Для просмотра всех веток, которые имеются сейчас в директории, имеется следующая команда:
```bash
git branch
```
Команда возвращает список всех доступных веток, а с помощью `*` отображает ветку, на которой Вы сейчас находитесь.


### 8.2. Добавление новой ветки и переключение на неё
Для того, чтобы добавить новую ветку для работы и перейти на неё, необходимо воспользоваться следующими операциями:
```bash
git branch <name_branch>    - создание новой ветки
git checkout <name_branch>  - переключение на новую ветку
```

Работа с новой веткой аналогична, как и основной. Если добавить в неё новые файлы, то можно спокойно коммитить изменения и потом посмотреть историю всех коммитов. 

Помимо создания ветки из текущей, можно создать ветку с корнем из любой другой. Это можно сделать немного дополнив основное создание ветки. В большинстве случаев ветки создаются из `master`, очень редко из каких-то других:
```
git branch <name_branch> <main_branch>
```

Имеется операция для одновременного переключения и создания ветки, для этого необходимо дописать следующее:
```
git checkout -b <name_branch>
```

### 8.3. Слияние веток
Для того, чтобы слить ветки воедино, необходимо перейти на главную ветку и совершить следующее действие:
```
git checkout master  - возврат на ветку master
git merge dev        - объединение ветки с dev  
```

Слияние ещё не говорит о том, что ветка перестает работать. 
Слияние - это объединение изменений с текущей веткой, на которой Вы находитесь.

### 8.4. Удаление веток
Если мы понимаем, что какие-то из веток потеряли свою актуальность, их можно удалить с помощью следующей операции:
```
git branch -d <branch_name>
```

Если происходит удаление при работе с удаленными репозиториями, то эта процедура удалит ветки только с локального. Для удаления с удаленного, нужно воспользоваться следующей операцией:
```
git push --delete origin <branch_name>
```

### 8.5. Перенос изменений ветки
Есть возможность изменения старта ветки, эта процедура перемещает Ваши изменения в тот или иной момент времени. Например, можно обновить точку старта на ту, которую внес уже другой разработчик. То есть без добавления коммитов смещаем начало ветки:

```
git rebase <branch_name>  - хотим сейчас сместить текущую ветку на последний коммит с ветки <branch_name>
```

Если возникла ситуация, что github не захочет принимать изменения после всех манипуляций, можно принудительно обновить с прекращением поддержки старой истории изменений. Для этого необходимо воспользоваться операцией:

```
git push --force  - данная операция ПРИНУДИТЕЛЬНО перезаписывает удаленную ветку на текущую
```

### 8.6. Основные команды по работе с ветками


``` bash
git branch # показать список веток, текущая ветка будет отмечена звездочкой *
git branch new_branch # создать новую ветку с указанным именем на текущем коммите
git checkout new_branch # перейти в указанную ветку
git merge hotfix # влить в ветку, в которой находимся, данные из ветки hotfix
git branch -d hotfix # удалить ветку hotfix (используется, если её изменения уже влиты в главную ветку)
git branch --merged # показать ветки, уже слитые с активной
```

Следующие опции позволяют:
``` bash
`git branch --all` # увидеть все ветки вместе с текущей веткой,  обозначенной значком `*`
`git branch --no-merged` # увидеть еще неслитые ветки
`git branch -move` # переименовать ветку
`git branch -d` # удалить ветку
```

Для переключения между ветками используется комманда `git switch`.

Для слияния веток используется комманда `git merge`.

Для смены "базы-основания" ветки используется комманда `git rebase`.


## 9. Конфликт слияния

Предполагается ситуация: есть ветка `master` и есть ветка `feature`. В обеих ветках есть коммиты, сделанные после расхождения веток. В ветку `master` пытаемся влить ветку `feature` (`git merge feature`), получаем конфликт, т.к. в обеих ветках есть изменения одной и той же строки в файле `index.html`.

При возникновении конфликта, репозиторий находится в состоянии прерванного слияния. Нужно оставить в конфликтующих местах файлов только нужный код, проиндексировать изменения и закоммитить.

``` bash
git merge feature                # влить в активную ветку изменения из ветки feature
git merge-base master feature    # показать хеш последнего общего коммита для двух указанных веток
git checkout --ours index.html   # оставить в конфликтном файле (index.html) состояние ветки, В КОТОРУЮ мы вливаем (в примере — из ветки master)
git checkout --theirs index.html # оставить в конфликтном файле (index.html) состояние ветки, ИЗ КОТОРОЙ мы вливаем (в примере — из ветки feature)
git checkout --merge index.html  # показать в конфликтном файле (index.html) сравнение содержимого сливаемых веток (для ручного редактирования)
git checkout --conflict=diff3  --merge index.html # показать в конфликтном файле (index.html) сравнение содержимого сливаемых веток плюс то, что было в месте конфликта в коммите, на котором разошлись сливаемые ветки
```

``` bash
git reset --hard  # прекратить это прерванное слияние, вернуть рабочую директорию и индекс как было в момент коммита, на который указывает HEAD, а я пойду немного поплачу
git reset --merge # прекратить это прерванное слияние, но оставить изменения, не закоммиченные до слияния (для случая, когда слияние делается не на чистом статусе)
git reset --abort # то же, что и строкой выше
```

## 10. Работа с удаленными репозиториями Git

`GitHub` — это удаленный хостинг репозиториев git. То есть это коммерческий сервис для размещения git-репозиториев и управления ими, своего рода Dropbox для хранения картинок или Google Диск для хранения файлов.

Для небольших команд `GitHub` бесплатный и его функций хватит для разработки небольших публичных проектов, однако, если вы хотите разрабатывать серьезные коммерческие продукты в большой команде и вам нужна приватность — придется раскошелиться.

`GitHub` обладает множеством полезных функций, которые сильно облегчают разработку и продакшн проектов:

Система безопасной авторизации по токенам;
Инструменты тестирования и анализа кода;
Сервисы деплоя проектов — GitHub actions.
Надо сказать, что у `GitHub` немало конкурентов: gitLab, BitBucket, SourceForge, Launchpad, Apache Allura и многие другие сервисы. Такое большое обилие сервисов обосновано тем, что само ядро git-сервера, на котором работает gitHUB и его конкуренты — бесплатное и никто не запрещает вам самому создать собственный git-сервис со своими уникальными фишками.

### 10.1. Порядок работы с GitHub
Для синхронизации с GitHub, необходимо выполнить несколько действий.
1. Необходимо зарегистрироваться и создать аккаунт на GitHub.
2. Создать репозиторий на GitHub.
3. Зайти в созданный репозиторий, нажать на кнопку `< > Code`.
4. Скопировать `url` ссылку.
5. Для создания синхронизации между локальными файлами и сервисами GitHub, необходимо выполнить следующую команду в локальном репозитории: 
```bash
git remote add origin https://github.com/name/repository.git
```
Где *`git remote add`* - добавляет удаленный источник, *`origin`* - название удаленного источника, в большинстве случаем *ВСЕ* удаленные источники называются именного так по умолчанию, и далее идёт ссылка на источник.

Для того, чтобы убедиться, что команда прошла успешно, необходимо выполнить следующее: 
```bash
git remote -v
```
Это покажет список всех подключенных к remote соединений.

6. Для того, чтобы отправить локальный репозиторий на GitHub, нужно воспользоваться следующей командой:
```bash
git push
```

Однако стоит отметить, что если ветки с изменением нет на гитхаб, то он не позволит это сделать. Для этого нужно зайти на гитхаб, создать ветку там, или воспользоваться расширенным вариантом
```bash
git push --set-upstream origin dev # где --set-upstream - источник в удаленном репозитории, origin - под названием origin (remote репозиторий), dev - название ветки, которую необходимо создать.
```
```bash
Или более сокращенным вариантом расширенного режима: # git push -u origin dev
```
7. После успешной отправки репозитория на GitHub, можно перейти на сайт и изменить файл, который был только что добавлен. Для отправки измененной версии с удаленного репозитория на локальный необходимо воспользоваться операцией: 
```bash
git pull
```

8. Стоит отметить ещё одну функцию, которая полезна при работе с GitHub, она нужна для того, чтобы обновить текущую синхронизацию по данным об удаленном репозитории. Например, если кто-то создал новую ветку, а Вы с ней не работали, эта операция загрузит эти данные Вам в локальный репозиторий и в последствии можно будет переключаться на ветки, которые создавались другими пользователями:
```bash
git fetch
```

Note! При такой синхронизации, добавленная ветка может не отобразиться в списке веток, потому что там выходят ветки, на которые Вы переключались локально. Для успешного отбражения нужно хотя бы один раз переключиться на добавленную ветку.

### 10.2. `Fork` и `pull request` на `GitHub`

Модель «Fork + Pull» позволяет любому склонировать (fork) существующий репозиторий и сливать изменения в свой личный fork без необходимости иметь доступ к оригинальному репозиторию. Затем, изменения должны быть включены в исходный репозиторий его хозяином. Эта модель уменьшает количество телодвижений для новых contributors и популярна для open source проектов, так как позволяет людям работать независимо, без единого координирования.

1. Делаем копию репозитория

```bash
Сделать это очень просто: на странице репозитория имеется кнопочка «Fork», которую и следует нажать.

После чего, эту свою копию уже можно «стянуть» на свой компьютер # git clone git@github.com:username/fork.git
```

**Склонированный репозиторий имеет одну привязку к удалённому репозиторию, названную origin, которая указывает на вашу копию на GitHub, а не на оригинальный репозиторий, чтобы отслеживать изменения и в нём, вам нужно будет добавить другую привязку, названную, например, upstream.**

2. Делаем работу

Итак, в этой точке мы уже можем править код и делать коммиты. Если вы сделали все предыдущие шаги, чтобы потом вернуть ваши изменения в оригинальный репозиторий, то я настоятельно советую делать всю работу в отдельной тематической ветви разработки. Полезность этого станет ясна на этапе посылки pull request'а. 

```bash
git checkout -b feature #Создаёт новую ветвь, названную "feature" и делает её активной
```
Как только вы сделали работу (или её часть), отправьте её в свою копию репозитория на GitHub:

```bash
git push origin feature #Загружает изменения в текущей ветви в origin в ветвь feature
```

3. Возвращаем изменения: Pull request


- идите на страницу вашей копии репозитория на GitHub, выбирайте ветвь feature и жмите кнопку Pull Request.

- далее вы попадёте на предпросмотровую страницу, на которой сможете ввести название и описание ваших изменений.

- когда вы ввели название и описание и перепроверили список коммитов и изменения в файлы, попавшие в пулл реквест, нажмите кнопку Send pull request. Пулл реквест будет создан незамедлительно.


### 10.3. Основные команды с удаленным репозиторием
``` bash
git remote -v              # показать список удалённых репозиториев, связанных с локальным
git branch -r              # показать удаленные ветки
git branch -a              # показать все ветки(локальные и удаленные)       
git remote remove origin   # убрать привязку удалённого репозитория с сокр. именем origin
git remote add origin https://github.com:nicothin/test.git # добавить удалённый репозиторий (с сокр. именем origin) с указанным URL
git remote rm origin       # удалить привязку удалённого репозитория
git remote show origin     # получить данные об удалённом репозитории с сокращенным именем origin
git fetch origin           # скачать все ветки с удаленного репозитория (с сокр. именем origin), но не сливать со своими ветками
git fetch origin master    # то же, но скачивается только указанная ветка
git checkout --track origin/github_branch # создать локальную ветку github_branch (данные взять из удалённого репозитория с сокр. именем origin, ветка github_branch) и переключиться на неё
git push origin master     # отправить в удалённый репозиторий (с сокр. именем origin) данные своей ветки master
git pull origin            # влить изменения с удалённого репозитория (все ветки)
git pull origin master     # влить изменения с удалённого репозитория (только указанная ветка)
```


## 10. Работа в консоли Vim

### 10.1. Длинный вывод в консоли: Vim

Вызов некоторых консольных команд приводит к необходимости очень длинного вывода в консоль (пример: вывод истории всех изменений в файле командой `git log -p fileName.txt`). При этом прямо в консоли запускается редактор [Vim](https://ru.wikipedia.org/wiki/Vim). Он работает в нескольких режимах, из которых Вас заинтересуют режим вставки (редактирование текста) и нормальный (командный) режим. Чтобы попасть из Vim обратно в консоль, нужно в командном режиме ввести <kbd>:q</kbd>. Переход в командный режим из любого другого: <kbd>Esc</kbd>.

Если нужно что-то написать, нажмите <kbd>i</kbd> — это переход в режим вставки текста. Если нужно сохранить изменения, перейдите в командный режим и наберите <kbd>:w</kbd>.

### 10.2. Vim (некоторые команды)

```bash
# Нажатия кнопок
ESC     — переход в командный режим
i       — переход в режим редактирования текста
ZQ (зажат Shift, поочередное нажатие) — выход без сохранения
ZZ (зажат Shift, поочередное нажатие) — сохранить и выйти
```bash
# Нажатия кнопок
ESC     — переход в командный режим
i       — переход в режим редактирования текста
ZQ (зажат Shift, поочередное нажатие) — выход без сохранения
ZZ (зажат Shift, поочередное нажатие) — сохранить и выйти

# Ввод в командном режиме
:q!             — выйти без сохранения
:wq             — сохранить файл и выйти
:w filename.txt — сохранить файл как filename.txt

```

## 11. Примеры
### Начало работы

Создание нового репозитория, первый коммит, привязка удалённого репозитория с gthub.com, отправка изменений в удалённый репозиторий.

``` bash
# указана последовательность действий:
# создана директория проекта, мы в ней
git init                      # создаём репозиторий в этой директории
touch readme.md               # создаем файл readme.md
git add readme.md             # добавляем файл в индекс
git commit -m "Старт"         # создаем коммит
git remote add origin https://github.com:nicothin/test.git # добавляем предварительно созданный пустой удаленный репозиторий
git push -u origin master     # отправляем данные из локального репозитория в удаленный (в ветку master)
```

### «Внесение изменений» в коммит

Только если коммит ещё не был отправлен в удалённые репозиторий.

``` bash
# указана последовательность действий:
subl inc/header.html          # редактируем и сохраняем разметку «шапки»
git add inc/header.html       # индексируем измененный файл
git commit -m "Убрал телефон из шапки" # делаем коммит
# ВНИМАНИЕ: коммит пока не был отправлен в удалённый репозиторий
# сознаём, что нужно было еще что-то сделать в этом коммите.
subl inc/header.html          # вносим изменения
git add inc/header.html       # индексируем измененный файл (можно git add .)
git commit --amend -m "«Шапка»: выполнена задача №34" # заново делаем коммит
```

### Работа с ветками

Есть master (публичная версия сайта), выполняем масштабную задачу (переверстать «шапку»), но по ходу работ возникает необходимость подправить критичный баг (неправильно указан контакт в «подвале»).

``` bash
# указана последовательность действий:
git checkout -b new-page-header # создадим новую ветку для задачи изменения «шапки» и перейдём в неё
subl inc/header.html            # редактируем разметку «шапки»
git commit -a -m "Новая шапка: смена логотипа" # делаем коммит (работа еще не завершена)
# тут выясняется, что есть баг с контактом в «подвале»
git checkout master             # возвращаемся к ветке master
subl inc/footer.html            # устраняем баг и сохраняем разметку «подвала»
git commit -a -m "Исправление контакта в подвале" # делаем коммит
git push                        # отправляем коммит с быстрым критическим изменением в master в удалённом репозитории
git checkout new-page-header    # переключаемся обратно в ветку new-page-header для продолжения работ над «шапкой»
subl inc/header.html            # редактируем и сохраняем разметку «шапки»
git commit -a -m "Новая шапка: смена навигации" # делаем коммит (работа над «шапкой» завершена)
git checkout master             # переключаемся в ветку master
git merge new-page-header       # вливаем в master изменения из ветки new-page-header
git branch -d new-page-header   # удаляем ветку new_page_header
```

### Работа с ветками, слияние и откат к состоянию до слияния

Была ветка `fix`, в которой исправляли баг. Исправили, влили `fix` в `master`. но тут выяснилось, что это исправление ломает какую-то функциональность, Нужно откатить `master` к состоянию без слияния (наличие бага менее критично, чем порча функциональности).

``` bash
# находимся в ветке fix, баг уже «исправлен»
git checkout master            # переключаемся на master
git merge fix                  # вливаем изменения из fix в master
# видим проблему: часть функциональности сломалась
git checkout fix               # переключаемся на fix (пока мы в master, git не даст ее двигать)
git branch -f master ORIG_HEAD # передвигаем ветку master на коммит, указанный в ORIG_HEAD (тот, на который указывала master до вливания fix)
```

### Работа с ветками, конфликт слияния

Есть ветка `master` (публичная версия сайта), в двух параллельных ветках (`branch-1` и `branch-2`) было отредактировано одно и то же место одного и того же файла, первую ветку (`branch-1`) влили в master, попытка влить вторую вызывает конфликт.

``` bash
# указана последовательность действий:
git checkout master           # переключаемся на ветку master
git checkout -b branch-1      # создаём ветку branch-1, основанную на ветке master
subl .                        # редактируем и сохраняем файлы
git commit -a -m "Правка 1"   # коммитим
git checkout master           # возвращаемся к ветке master
git checkout -b branch-2      # создаём ветку branch-2, основанную на ветке master
subl .                        # редактируем и сохраняем файлы
git commit -a -m "Правка 2"   # коммитим
git checkout master           # возвращаемся к ветке master
git merge branch-1            # вливаем изменения из ветки branch-1 в текущую ветку (master), удача (автослияние)
git merge branch-2            # вливаем изменения из ветки branch-2 в текущую ветку (master), КОНФЛИКТ автослияния
# Automatic merge failed; fix conflicts and then commit the result.
subl .                        # выбираем в конфликтных файлах те участки, которые нужно оставить, сохраняем
git commit -a -m "Устранение конфликта" # коммитим результат устранения конфликта
```

### Синхронизация репозитория-форка с мастер-репозиторием

Есть некий репозиторий на github.com, от него нами был сделан форк, добавлены какие-то изменения. Оригинальный (мастер-)репозиторий был как-то обновлён. Задача: стянуть с мастер-репозитория изменения (которые там внесены уже после того, как мы его форкнули).

``` bash
# указана последовательность действий:
git remote add upstream https://github.com:address.git # добавляем удаленный репозиторий: сокр. имя — upstream, URL мастер-репозитория
git fetch upstream            # стягиваем все ветки мастер-репозитория, но пока не сливаем со своими
git checkout master           # переключаемся на ветку master своего репозитория
git merge upstream/master     # вливаем стянутую ветку master удалённого репозитория upstream в свою ветку master
```

### Ошибка в работе: закоммитили в мастер, но поняли, что нужно было коммитить в новую ветку

**ВАЖНО: это сработает только если коммит еще не отправлен в удалённый репозиторий.**

``` bash
# указана последовательность действий:
# сделали изменения, проиндексировали их, закоммитили в master, но ЕЩЁ НЕ ОТПРАВИЛИ (не делали git push)
git checkout -b new-branch    # создаём новую ветку из master
git checkout master           # переключаемся на master
git reset HEAD~ --hard        # сдвигаем указатель (ветку) master на 1 коммит назад
git checkout new-branch       # переключаемся обратно на новую ветку для продолжения работы
```

### Нужно вернуть содержимое файла к состоянию, бывшему в каком-либо коммите (известен хеш коммита)

``` bash
# указана последовательность действий:
git checkout f26ed88 -- index.html # восстановить в рабочей директории состояние указанного файла на момент указанного коммита, добавить это изменение в индекс
git commit -am "Navigation fixs"   # сделать коммит
```


## 12. Тренажеры для отработки работы с Git

Для облегчения обучения, оставлю вам пару ссылок на бесплатные тренажера по Git, если будет желание ознакомтесь: [раз](https://learngitbranching.js.org/) и [два](https://www.schoolsw3.com/git/exercise.php). 

# Конец
![Ералаш, все!](Eralasch.jpeg)


