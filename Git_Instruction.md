![git Logo](images\Git-Logo-White.png)
# Работа с GIT

## 1. Проверка наличия установвленного Git..

В терминале выполнить команду `git --version` 
Если git установлен, появится сообщение о версии программы, в противном случае будет выведена информация об ошибке.
## 2. Установка Git.
Загружаем последнюю версию Git с [сайта](https://git-scm.com/downloads).
Устанавливаем программу с настройками по умолчанию.
## 3. Настройка Git.
При первом использовании Git, необходимо представиться.
Для этого необходимо ввести в терминале две команды:
```Bash
git config --global user.name «Ваше имя английскими буквами»
git config --global user.email ваша почта@example.com
```
## 4. Подготовка к работе. Инициализация репозитория.
Перед началом работы с Git, необходимо обозначить каталог в котором будут проводится работы. Инициализация выполняется с помощью команды
```Bash
git init
```
После выполнения данной команды в рабочем каталоге появитсяя скрытая директория
```Bash
./git
```
в которой будет хранится вся информация о проделанной работе.


## 5. Внесение изменений в репозиторий.

Для проверки файлов в которые были внесены изменения используется команда
```
git status
```
Все файлы подвергнувшиеся изменению будут выделены красным цветом.

Для добавления всех изменённых, либо созданных файлов в репозиторий используется команда
```Bash
git add .
```
Данная команда автоматически отметит все внесённый изменения во всех файлах в следующий коммит.

Для внесения изменений в один, либо несколько файлов используется команда : 
```
git add Название_файла, или несколько файлов через запятую.
```

## 6. Сохранение изменений.
Для сохранения изменений. Git использует систему ***коммитов***.

***Коммиты*** — основные конструктивные элементы временной шкалы проекта Git. Их можно рассматривать как снимки состояния или контрольные точки на временной шкале проекта Git. Коммиты создаются с помощью команды: 
```
git commit
```
 которая делает снимок состояния проекта на текущий момент времени.

 Теперь наш файл находится под наблюдением git, необходимо сохранить изменения в
репозитории. Сделаем первый коммит:
 ```
 git commit -­m "My first commit"
 ``` 

Ключ -­m позволяет задать описание коммита. Описание обязательно, иначе
коммит не будет выполнен. 

Так же можно совместить одновременное добавление изменений и коммит, сделать это можно с помощью ключа -a. Данный ключ равнозначен коменде git add .

Пример команды:
```
git commit -am 'Add some code'
```
Сперва выполниться команда
```
git add .
```
А вслед за ней
```
git commit -m ""
```

## 7. Просмотр фиксаций и отслеживание изменений в коммитах.

Для просмотра все выполненных фиксаций можно воспользоваться историей коммитов. Она содержит сведения о каждом проведенном коммите проекта. Запросить ее можно при помощи команды:

```
git log
```
В ней содержится вся информация о каждом отдельном коммите, с указанием его хэша, автора, списка изменений и даты, когда они были сделаны. Отследить интересующие вас операции в списке изменений, можно по хэшу коммита, при помощи команды git show :

```
git show hash_commit
```
Ну а если вдруг нам нужно переделать commit message и внести туда новый комментарий, можно написать следующую конструкцию:

```
git commit --amend -m 'Новый комментарий'
```
В данном случае сообщение последнего коммита перезапишется. Но злоупотреблять этим не стоит, поскольку эта операция опасная и лучше ее делать до отправки коммита на сервер.


У каждого коммита есть свой уникальный идентификатор в виде строки цифр и букв. Чтобы просмотреть список всех коммитов и их идентификаторов, можно использовать команду log:
```
git log
```
Как вы можете заметить, идентификаторы довольно длинные, но для работы с ними не обязательно копировать их целиком — первых нескольких символов будет вполне достаточно. Чтобы посмотреть, что нового появилось в коммите, мы можем воспользоваться командой show :

```
git show хеш код коммита
```

Чтобы увидеть разницу между двумя коммитами, используется команда diff:

```
git diff
```
Мы сравнили первый коммит с последним, чтобы увидеть все изменения, которые были когда-либо сделаны. Обычно проще использовать git difftool, так как эта команда запускает графический клиент, в котором наглядно сопоставляет все изменения.


## 8. Возвращение файла к предыдущему состоянию.

Гит позволяет вернуть выбранный файл к состоянию на момент определенного коммита. Это делается командой checkout. Она также может быть использована для переключения между коммитами (это довольно распространенная ситуация для Гита - использование одной команды для различных, на первый взгляд, слабо связанных задач).
Однако в современных версиях git, разработчики рекомендуют использовать команду 

```
git switch
```

В следующем примере мы возьмем файл hello.txt и откатим все изменения, совершенные над ним к первому коммиту. Чтобы сделать это, мы подставим в команду идентификатор нужного коммита, а также путь до файла:

```
git checkout 09bd8cc1 hello.txt
```

## 9. Возврат к актуальному состоянию.

 Вернуться к актуальному состоянию и продолжить работу можно с посощью команды
 ```
 git checkout master
 ```
## 10. Игнорирование файлов.
Для того, чтобы исключить из отслеживания, определённые файлы и папки, необходимо создать файл ***.gitignore*** и добавить в него название файла или папки или их шаблоны.

## 11. Ветвление.

Во время разработки новой функциональности считается хорошей практикой работать с копией оригинального проекта, которую называют веткой. Ветви имеют свою собственную историю и изолированные друг от друга изменения до тех пор, пока вы не решаете слить изменения вместе. Это происходит по набору причин:

- Уже рабочая, стабильная версия кода сохраняется.

- Различные новые функции могут разрабатываться параллельно разными программистами.

- Разработчики могут работать с собственными ветками без риска, что кодовая база поменяется из-за чужих изменений.

- В случае сомнений, различные реализации одной и той же идеи могут быть разработаны в разных ветках и затем сравниваться.

### 12. Создание новой ветки.
Основная ветка в каждом репозитории называется master, в нашем случае основная ветка будет называться `main`. Чтобы создать еще одну ветку, используем команду 
```
git branch <name>
```
Пример:
```
git branch reateBranches
```
Данная команда создаст новую ветку, пока что точную копию ветки master.

### 13. Переключение между ветками.

Сейчас, если мы запустим branch, мы увидим две доступные опции:
![Alt text](/images/image.png)

`main `— это активная ветка, она помечена звездочкой. Но мы хотим работать с нашей “новой потрясающей фичей”, так что нам понадобится переключиться на другую ветку. Для этого воспользуемся командой checkout, она принимает один параметр — имя ветки, на которую необходимо переключиться.

```
git checkout createBranches
```
Теперь проверим: 

![Alt text](/images/image1.png)

Видим, что активная ветка сменилась.

В Git `ветка` — это отдельная линия разработки. `git checkout` и `git swich` позволяет нам переключаться как между удаленными, так и меду локальными ветками. Это один из способов получить доступ к работе коллеги или соавтора, обеспечивающий более высокую продуктивность совместной работы. Однако тут надо помнить, что пока вы не закомитили изменения, вы не сможете переключиться на другую ветку. В такой ситуации нужно либо сделать коммит, либо отложить его, при помощи команды 
```
git stash
``` 
добавляющей текущие незакоммиченные изменения в стек изменений и сбрасывающей рабочую копию до HEAD'а репозитория.

### 14. Слияние веток
Наша “потрясающая новая фича” будет еще одним текстовым файлом под названием feature.txt. Мы создадим его, добавим и закоммитим:

```Bash
$ git add feature.txt
$ git commit -m "New feature complete.”
```
Изменения завершены, теперь мы можем переключиться обратно на ветку `main`

```Bash
$ git checkout maim

```

Теперь, если мы откроем наш проект в файловом менеджере, мы не увидим файла `feature.txt`, потому что мы переключились обратно на ветку `main`, в которой такого файла не существует. Чтобы он появился, нужно воспользоваться командой `merge `для объединения веток (применения изменений из ветки amazing_new_feature к основной версии проекта).
```Bash
git merge createBranch
```
Теперь ветка `main` актуальна. Ветка createBranch больше не нужна, и ее можно удалить.

```Bash
git branch -d createBranch
```
Если хотите создать копию удаленного репозитория - используйте `git clone`. Однако если вам нужна только определенная его ветка, а не все хранилище - после git clone выполните следующую команду в соответствующем репозитории:

```Bash
git checkout -b <имя ветки> origin/<имя ветки>
```
После этого, новая ветка создается на машине автоматически.

### 15. Как удалять ветки в Git?

Бывают ситуации, когда после слива каких-то изменений из рабочей ветки в исходную версию проекта, ее, по правилам хорошего тона, необходимо удалить, чтобы она более не мешалась в вашем коде. Но как это сделать?
Для локально расположенных веток существует команда:

```Bash
git branch -d local_branch_name
```
где флажок -d являющийся опцией команды `git branch` - это сокращенная версия ключевого слова `--delete`, предназначенного для удаления ветки, а local_branch_name – название ненужной нам ветки.
Однако тут есть нюанс: удалить текущую ветку, в которую вы, в данный момент просматриваете - нельзя. Если же вы все-таки попытаетесь это сделать, система отругает вас и выдаст ошибку с таким содержанием:
```bash
Error: Cannot delete branch local_branch_name checked out at название_директории

```
Так что при удалении ветвей, обязательно переключитесь на другой branch.

### 16. Разрешение конфликтов при слиянии
Помимо сценария, описанного в предыдущем пункте, конфликты регулярно возникают при слиянии ветвей или при отправке чужого кода. Иногда конфликты исправляются автоматически, но обычно с этим приходится разбираться вручную — решать, какой код остается, а какой нужно удалить.
Давайте посмотрим на примеры, где мы попытаемся слить две ветки под названием john_branch и tim_branch. И Тим, и Джон правят один и тот же файл: функцию, которая отображает элементы массива.
Джон использует цикл:

```js
// Use a for loop to console.log contents.
for(var i=0; i<arr.length; i++) {
console.log(arr[i]);
}
```

Тим предпочитает forEach:

```Js
// Use forEach to console.log contents.
arr.forEach(function(item) {
console.log(item);
});
```

Они оба коммитят свой код в соответствующую ветку. Теперь, если они попытаются слить две ветки, они получат сообщение об ошибке:

```Bash
$ git merge tim_branch
Auto-merging print_array.js
CONFLICT (content): Merge conflict in print_array.js
Automatic merge failed; fix conflicts and then commit the result.
```

Система не смогла разрешить конфликт автоматически, значит, это придется сделать разработчикам. Приложение отметило строки, содержащие конфликт:

```Bash
<<<<<<< HEAD // Use a for loop to console.log contents. for(var i=0; i<arr.length; i++) { console.log(arr[i]); } ======= // Use forEach to console.log contents. arr.forEach(function(item) { console.log(item); }); >>>>>>> Tim's commit.

```
Над разделителем ======= мы видим последний (HEAD) коммит, а под ним - конфликтующий. Таким образом, мы можем увидеть, чем они отличаются и решать, какая версия лучше. Или вовсе написать новую. В этой ситуации мы так и поступим, перепишем все, удалив разделители, и дадим git понять, что закончили.

```js
// Not using for loop or forEach.
// Use Array.toString() to console.log contents.
console.log(arr.toString());
```
Когда все готово, нужно закоммитить изменения, чтобы закончить процесс:

```Bash
$ git add -A
$ git commit -m "Array printing conflict resolved."
```
Как вы можете заметить, процесс довольно утомительный и может быть очень сложным в больших проектах. Многие разработчики предпочитают использовать для разрешения конфликтов клиенты с графическим интерфейсом. (Для запуска нужно набрать git mergetool).
