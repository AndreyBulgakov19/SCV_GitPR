<!---Логотит Git--->
![logo](logos\Git-Logo-1788C.png)
# Инструкция для работы с Git и удалёнными репозиториями
# Что такое Git (понятие и определение)
***Git*** - это консольная утилита (программа) для отслеживания и ведения истории изменения файлов (например, текста программного кода), которая служит для контроля версий проекта, берёт на себя контроль этих версий и позволяет переключаться между ними. Git хранит не файлы целиком, а отличия (изменения) между ними, что позволяет экономить память.
>Автор программы создатель ОС Linux - Линус Торвальдс.

[//]: # (Шаги инструкции)
## 1. Установка и настройка ПО (Git и Visual Studio Code)
Для системы контроля версий *(VCS)* используется следующее ПО: **Git** и **Visual Studio Code**. Для установки последних актуальных версий ПО необходимо перейти по следующим ссылкам:
- [Установить **Git** для Windows, MAC, Linux](https://git-scm.com/downloads)
- [Установить **VSCode** для Windows, MAC, Linux](https://code.visualstudio.com/Download)
>При установке придержимается параметров по умолчанию.

После установки ПО необходимо «представиться» системе контроля версий *(VCS)*. Это нужно сделать всего один раз. Для этого нужно ввести в терминале 2 команды:
```bash
    git config --global user.name "<имя_пользователя>"
    git config --global user.email "<адрес_почты@email.com>"
```
## 2. Создание и инициализация репозитория
___Репозиторий___ - хранилище кода и истории его изменений. **Git** работает локально и все репозитории хранятся в определенных папках на жестком диске. Так же репозитории можно хранить в глобаленой сети. Обычно для этого используют следующие сервисы: **GitHub, Bitbucket, GitLab**.

### Для работы используется выбранный нами терминал (PS, bash либо др.), в котором для создания и инициализации репозитория, а также последующих действий, необходимо выполнить следующие команды:
1. Проверить текущую установленную версию программы Git:
```bash
    git --version
```
> Если Git установлен, то появится сообщение о версии программы, в противном случае выводится сообщение об ошибке.
2. Выполнить инициализацию репозитория (указываем папку, в которой Git начнёт отслеживать изменения, в папке создаётся _скрытая папка_ ***.git***):
```bash
    git init
```
> Инициализация производится из папки репозитория!
3. Вывести текущее состояние Git, посмотреть есть ли изменения, которые нужно закоммитить (_commit - сохранить, зафиксировать_):
```bash
    git status
```
> Действие команды распространяется на подготовленные, неподготовленные и неотслеживаемые файлы.
4. Добавить отдельный файл или все файлы в область подготовленных файлов содержимого рабочего каталога для последующего коммита (делается после добавления файлов). Добавить отдельный файл в область подготовленных файлов можно командой *add* с указанием имени файла. Кроме того, можно добавить все файлы и папки в эту область, предоставив "." вместо имени файла.
 ```bash
    git add
    git add .
```
## 3. Запись изменений в репозиторий, создание коммитов
Для записи индексированных изменений в репозиторий Git используется следующая команда:
```bash
    git commit -m "Message about the commit"
```
>При создании коммита в репозитории можно добавить однострочное сообщение комментария с помощью параметра **commit** с флагом **-m** либо же добавить комментарий через текстовый редактор, в котором информационное сообщение может состоять из нескольких строк текста. Команда **git commit** берёт все данные, добавленные в индекс с помощью **git add**, и сохраняет их слепок во внутренней базе данных, а затем сдвигает указатель текущей ветки на этот слепок.
## 4. Просмотр истории коммитов
Перед переключением версии файла в Git можно использовать следующую команду, чтобы увидеть историю и количество сохранений:
```bash
    git log
```
## 5. Перемещение между фиксированными сохранениями (коммитами)
Для того чтобы вернуться или перейти к нужному выбранному коммиту в истории репозитория можно воспользоваться командой с хэшем (уникальным номером) коммита:
```bash
    git checkout [хэш коммита]
```
>При необходимости можно указать не только интересующий коммит, но и вернуться в тот, где работаем, при помощи команды *git checkout master*
## 6. Просмотр изменений до коммита
Для того чтобы просмотреть список изменений, внесённых в репозиторий, используя параметр *diff*. По умолчанию отображаются только изменения, не подготовленные для фиксации.
```bash
    git diff
```
## 7. Игнорирование файлов и папок в Git
Для исключения из идексации и отслеживания Git файлов и папок необходимо создать в корневом каталоге репозитория тектовый файл **.gitignore**, в котором указываются список всех фалов и папок для игнорирования отслеживания:
```markdown
   /folder
   file_name*.*
```
После довавления в файл **.gitignore** исключений для отсеживания, необходимой добавить данный файл для отслеживания и выпонить коммит (команды _git add_ и _git commit_ )
> */folder* - относительный пусть к папке.

> *file_name* - относительный пусть расположения файлов игнорирования, с указанием расширения файла или маски. 

## 8. Создание веток в Git

**Ветка (branch)** — это набор фиксированных изменений (коммитов), расположенных в хронологическом порядке. У каждой ветки есть свое имя (название). Основная ветка чаще всего называется *master* (*main, dev* - выбирается самостоятельно), она появляется при инициализации репозитория и считается главной веткой проекта. Другим веткам даются имена по смыслу. Дополнительные ветки используются для создания нового функционала, работы с черновиками и исправления ошибок.
Для создания веток могут применяться следующие команды:
```bash
    git branch <new_branch_name>
    git checkout -b <new_branch_name>
    git switch -c <new_branch_name>
```
>При создании новой ветки и _автоматического_ перехода для работы с ней применяется команда _git checkout -b_

Для просматра полного список локальных веток репозитория используется параметр _branch_. Команда отобразит все ветки, при этом отметит текущую звёздочкой (\*) и выделит её цветом. Если требуется показать все ветвления (включая ветки удаленного репозитория), необходимо добавить флаг _-a_. Задействовав флаг _-r_, будет выведен список только удаленных веток.
```bash
    git branch
    git branch -a
```
Для переключения с одной ветки на другую может производится вызовем одной из следующих команд:
```bash
 git checkout <branch_name>
 git switch <branch_name>
```
## 9. Слияние веток и разрешение конфликтов
После того, как произведена работа над задачей в другой ветке, эту ветку (например, <existing_branch_name>) можно слить в основную (master). Для этого нужно переключиться в основную ветку и выполнить слияние:
```bash
    git branch <branch_master>
    git merge <existing_branch_name>
```
либо
```bash
    git switch <branch_master>
    git merge <existing_branch_name>
```
>Команда _merge_ берет все изменения из ветки (<existing_branch_name>) и добавляет (сливает) их в текущую ветку. Git старается автоматически сливать изменения, однако это не всегда возможно. Иногда возникают конфликты. Например, когда в двух ветках были изменения в одной и той же строчке кода. Если такое произошло, то необходимо разрешить конфликт вручную. VSCode предлагает выбрать одно из решений (какие изменения использовать) для решения конфликта при слиянии веток. После внесения нужных изменений необходимо добавьте файл через *git add <имя_файла>* как измененный и создайте новый commit.
## 10. Удаление веток
При завершении работы над дополнительной веткой и объединения (слияния) её с основной, можно удалить эту ветку без потери истории параметром команды _branch_ с добавлением флага _-d_ и указанием имени ветки:
```bash
    git branch -d <existing_branch_name>
```
>Однако, если выполнить команду удаления до слияния, то в результате появится сообщение об ошибке. Этот защитный механизм предотвращает потерю доступа к файлам.

При необходимости для принудительного удаления ветки используется флаг _-D_ с заглавной буквой. В этом случае ветка будет удалена независимо от текущего статуса, без предупреждений:
```bash
    git branch -D <existing_branch_name>
```
## 11. Графическое отображение журнала фиксации
Просмотреть историю коммитов в виде графика для текущей ветки можно с помощью параметра _log_ и флагов _--graph_ _--oneline_ _--decorate_. Опция --graph выведет график в формате ASCII, отражающий структуру ветвления истории коммитов. В связке с флагами _--oneline_ и _--decorate_, этот флаг упрощает визуальное понимание того, к какой ветке относится каждый коммит.
```bash
    git log --graph --oneline --decorate
```
Для просмотра истории коммитов по всем веткам используется флаг --all.
```bash
    git log --all --graph --oneline --decorate
```
## 12. Работа с удалёнными репозиториями (Git vs GitHub)
 ![logo](logos\GitHub_Logo.png)
**GitHub**- cервис компании Майкрософт, который предназначен для организации работы удаленных репозиториев, позволяет интегрироваться с локальным репозиториям **Git** и настроить работу с ним.
 Для работы с удаленным репозиторием на **GitHub** необходимо выполнить следующие шаги:
1. Создаmь аккаунт на **GitHub** (произвеcти процедуру регистрации).
2. Создать локальный репозиторий в новой папки, последовательно выполнить следующие команды (механизм создания локального репозитория описан выше)
```bash
    git status
    git init
    git add
    git commit -m "Message about the commit"
```
3. Создать удалённый репозиторий на **GitHub**. Для этого необходимо:
    - нажать кнопку `New` для создания репозитория.
    - указать имя репозитория, применить параметры настроек;
    - нажать кнопку `Greate a new repository`.
4. *GitHub* предоставит ссылку URL для созданного репозитория и предложит выполнить набор команд в зависимости от цели:
    - ...создайте новый репозиторий в командной строке;
    - ...отправить существующий репозиторий из командной строки;
    - ...импортируйте код из другого репозитория.
> Для выбора `...отправить существующий репозиторий из командной строки`:
```bash
	git remote add origin <ссылка на удаленный репозиторий>
	git branch -M main
	git push -u origin main
```
> *git remote add origin* - добавляет по URL (псевдоним *origin*) удаленный репозиторий; *git branch -M main* - переименовывает ветку, т.к. на удалённом репозитории  по умолчанию использыется ветка *main*; *git push -u origin main* - отправляет изменения в удалённый репозиторий.
5. Установить связь и взаимодействия между локальным и удалённым репозиториями. 
Для копирования внешнего репозитория в локальный репозиторий персонального компьютера применяется следующая команда:
```bash
	git clone <ссылка на удаленный репозиторий>
```
> Команда *git clone* не только загружает все изменения, но и пытается слить все ветки на локальном компьютере и в удаленном репозитории.
Для того, чтобы скачать всё из текущего внешнего репозитория в локальный (получение изменений из удаленного репозитория) и автоматически сделать *merge* (слияние) с нашей версией используется команда:
```bash
	git pull
```
Для того, чтобы отправить свою локальную версию репозитория во внешний репозиторий используется команда:
```bash
	git push
```
> Используется для синхронизации локальной рабочей копии и всех ссылочных объектов с удаленным репозиторием. При этом может потребоватся авторизация на внешний репозиторий!
## 13. Совместная работа **GitHub**. Cоздание *форков* и *пулл-реквестов*
**Форк** (*от англ. fork – вилка*) – точная копия репозитория, но только уже в нашем аккаунте *GitHub*. Форки нужны для того, чтобы вносить свои изменения в проект, к репозиторию которого у нас нет прямого доступа.
**Пулл-реквест** (*от англ. pull-request – запрос pull*) – функция *GitHub*, позволяющая попросить владельца репозитория, от которого мы сделали *форк*, загрузить наши изменения обратно в свой репозиторий.
Для совместной работы по созданию форков и отправки пулл-реквестов применим следующий набор действий:
1. Для начала необходимо зайти на страницу репозитория проекта. Нажимаем на кнопку **Fork**. После этого *Git* создаст точную копию этого репозитория в нашем аккаунте.
2. Клонируем репозиторий к себе на компьютер командой `git clone`. Создаём файл *README.md* с описанием проекта, чтобы другим пользователям было понятно, в чем отличие этой реализации от остальных.
3. Делаем коммит `git commit` и выполняем `git push`, чтобы загрузить наши изменения в удаленный репозиторий.
4. *GitHub* подсказывает нам, что наша ветка опережает ветку исходного репозитория на один коммит и предлагает сделать *пулл-реквест*.
5. Нажимаем на кнопку **Compare** на подсказке *GitHub*, либо переходим на вкладку **Pull Requests** и нажимаем **New pull request**.
6. Перед нами откроется страница создания пулл-реквеста, здесь необходимо описать, что за изменения внесли и почему они были необходимы. Сообщение, которое оставили здесь отражает суть и необходимость внесенных изменений. Как только мы закончили с описанием, можно нажимать кнопку **Create pull request**.
Именно так будет выглядеть наш *пулл-реквест* и для владельца репозитория. Владелей сможет писать комментарии, указывая на ошибки или задавая вопросы. После того, как владелец репозитория просмотрит наши изменения и убедится, что они не имеют вредоносный характер, он сможет принять наш пулл-реквест. Тогда все изменения, добавленные в этот пулл-реквест нами, будут залиты в исходный репозиторий.

# Основные команды Git:
- *git config* — вызывается для применения при первом использовании; 
- *git status* — получить информацию от Git о его текущем состоянии, есть ли изменения, которые нужно закоммитить;
- *git log* — вызывать на экран историю всех коммитов с их хэш-кодами,
- *git init* — создать репозиторий в папке на локальной машине,
- *git add* — добавить файл или файлы к следующему коммиту, отслеживать добавленные файлы;
- *git commit -m “message”* — сохранить (зафиксировать) текущее состояние с комментарием;
- *git diff* — показать разницу между версиями, увидеть разницу между текущим файлом и закоммиченным файлом;
- *git chechout* — переход от одного коммита к другому, а также переключиться между разными версиями;
- *git chechout master* — вернуться к актуальному состоянию и продолжить работу;
- *git branch* — выводит именена имеющихся ветов;
- *git switch -c new_branch_name* - создаёт новую ветку new_branch_name (альтернатива команды git chechout)
- *qit switch -* — вернуться в исходное состояние;
- *git merge* — слить любую ветку с текущей;
- *git log --graph* — ключ *"-graph"* в связке с командой *log* позволяет отобразить коммиты в виде дерева;
- *git help* — описание команд либо описание по конкретной команде *git ststus -h*
- *git clone <url-адрес репозитория>* – клонирование внешнего репозитория на локальный ПК;
- *git pull* – получение изменений и слияние с локальной версией;
- *git push* – отправляет локальную версию репозитория на внешний.