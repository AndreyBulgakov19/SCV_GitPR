![Logo](gitlogo.png) 
# Работа с Git

## 1. Проверка наличия установленного Git
В терминале выполнить команду `git --version`.
Если Git установлен, появится сообщение с информацией о версии программы, иначе будет сообщение об ошибке.

## 2. Установка Git
Загружаем последнюю версию Git с [сайта](https://git-scm.com/downloads) . 
Устанавливаем с настройками по умолчанию.

## 3. Настройка Git
При первом использовании Git необходимо представиться. Для этого нужно ввести в терминале 2 команды:
```
git config --global user.name "Ваше имя английскими буквами"
git config --global user.email "Ваша почта@example.com"
```
## 4. Инициализация репозитория
Git хранит свои файлы и историю прямо в папке проекта. Чтобы создать новый репозиторий, нам нужно открыть терминал, зайти в папку нашего проекта и выполнить команду `init` . Это включит приложение в этой конкретной папке и создаст скрытую директорию .git, где будет храниться история репозитория и настройки.

## 5. Запись изменений в репозитории
Добавить под контроль версий все существующие файлы можно командой `git add .` (точка в конце важна!). Можно добавлять и по одному файлу, с помощью `git add <имя файла>`.
В Git есть концепция области подготовленных файлов. Можно представить ее как холст, на который наносят изменения, которые нужны в коммите. Сперва он пустой, но затем мы добавляем на него файлы (или части файлов, или даже одиночные строчки) командой `git add` и, наконец, коммитим все нужное в репозиторий (создаем слепок нужного нам состояния) командой `git commit`.
Теперь создадим непосредственно сам коммит:
```
git commit -m 'Add some code'
```
Флажок `-m` задаст `commit message` - комментарий разработчика. Он необходим для описания закоммиченных изменений. 
Status — это еще одна важнейшая команда, которая показывает информацию о текущем состоянии репозитория: актуальна ли информация на нём, нет ли чего-то нового, что поменялось, и так далее. Запуск `git status` на нашем свежесозданном репозитории должен выдать:
```
$ git status
On branch master
Initial commit
Untracked files:
(use "git add ..." to include in what will be committed)
hello.txt
```
Команда `git diff` покажет разницу в изменениях.

## 6. Просмотр истории коммитов 
Для просмотра всех выполненных фиксаций можно воспользоваться историей коммитов. Она содержит сведения о каждом проведенном коммите проекта. Запросить ее можно при помощи команды `git log`.
В ней содержится вся информация о каждом отдельном коммите, с указанием его хэша, автора, списка изменений и даты, когда они были сделаны.

## 7. Перемещение между коммитами
Напомним, что Git сохраняет изменения в файле в репозитории целиком, что позволяет перемещаться между коммитами командой `git checkout`. Перемещаться между коммитами можно для просмотра удаленных частей кода или восстановления удаленных файлов.

Вообще, откреплять HEAD от ветки не рекомендуется, но это можно сделать для восстановления удаленных файлов. Откатываться назад и коммитить там — нельзя. Оно получится, но вы не увидите изменений в основной ветке. Перемещение между коммитами сделано только для ознакомления с состоянием файлов в прошлом, а вот перемещение между ветками — это базовая и очень полезная фишка git.

## 8. Игнорирование файлов
Для того,чтобы исключить из отслеживания в репозитории определённые файлы или папки необходимо создать там файл ***.gitignore*** и записать в него их названия или шаблоны, соответствующие таким файлам или папкам.

## 9. Создание веток в Git
По умолчанию имя основной ветки в Git - **master**.
Создать ветку можно командой:
```
git branch <имя новой ветки>
```
Список веток в репозитории можно посмотреть с помощью команды `git branch`.
Текущая ветка будет отмечена звездочкой: **\*master** .

Также мы можем создать ветку,на которую автоматически переключимся при помощи команды `git checkout -b <название новой ветки>`.

## 10. Слияние веток, разрешение конфликтов
Команда `git merge` используется для слияния одной или нескольких веток в текущую. Затем она устанавливает указатель текущей ветки на результирующий коммит.
Слияние выполняется после завершения работы над своей веткой.
```
git checkout master
git merge new
```
Слияние веток Git является основным процессом при работе у разработчиков. Бывает так, что разработчики в своих разных ветках изменяют один и тот же файл, а также одно и тоже место.

Git может автоматически объединить файлы, если они были изменены в разных местах и на разных строках.

Если вы запустили git merge и возник конфликт слияния, ваш терминал или командная строка ответит вам сообщением:

```
CONFLICT (content): Merge conflict in [filename]
```
Это сообщение говорит нам, в каком конкретно файле возник конфликт.

Что делать?
1. Найдите конфликт

Откройте файл, на который указал Git, и прокрутите его, пока не найдете конфликт. Ваша IDE может подсказать вам нужное место при помощи подсветки. В примере ниже показано, как это выглядит в VS Code. Редактор подсвечивает *текущее* изменение и *входящее*.

**Текущее изменение** (англ. current change) также иногда называют исходящим. Оно представляет изменения в коде, которые вы сделали в вашей локальной ветке.

**Входящее изменение** (англ. incoming change) представляет изменения в коде, которые вы вытягиваете (pull) из базовой ветки, или изменения, внесенные другими разработчиками.

Вы можете принять изменения, не делая коммит, и локально протестировать программу на работоспособность.

2. Удалите все длинные последовательности символов ==== , <<<< или >>>>
Эти символы используются для того, чтобы помочь вам определить, где возник конфликт слияния. При принятии выбранных изменений они обычно исчезают, но порой случаются сбои. Проследите за тем, чтобы случайно не включить их в коммит: это может привести к багам в программе.

Если вы допустили ошибку или не уверены в том, какие изменения нужно принять, вы можете остановить процесс слияния, запустив следующую команду:
**git merge --abort**.

Если вы уверены, что конфликт разрешен, сделайте коммит изменений
После принятия нужных изменений вы можете сделать коммит. Проделайте следующие шаги:
* Сохраните файлы, в которые были внесены изменения
* Запустите *git status* и проверьте, что изменения коснулись правильных файлов
* Добавьте выбранные файлы в стейджинг: *git add [имя файла]*
* Сделайте коммит изменений: *git commit -m «[ваше сообщение коммита]*».

## 11. Удаление веток
Локальные ветки – это ветки на вашем компьютере, которые не влияют на ветки удаленного репозитория.

Команда для удаления локальной ветки в Git:
```
git branch -d  local_branch_name
git branch – команда для удаления локальной ветки.
-d – флаг, опция команды git branch, сокращенный вариант записи --delete. Как и следует из названия, предназначен для удаления ветки.
local_branch_name – имя удаляемой ветки.
```
**Удалить ветку, в которой вы находитесь и которую просматриваете в данный момент, нельзя.**

Если мы попытаемся это сделать, то получим ошибку. Так что перед удалением локальной ветки обязательно переключитесь на другую, которую не собираетесь удалять.

Переход делается при помощи команды **git checkout**.

## 12. Работа с удаленным репозиторием
Для загрузки данных в удаленный репозиторий сначала нужно к нему подключиться. В нашем примере мы используем адрес https://github.com/tutorialzine/awesome-project, однако пользователь может создать собственный удаленный репозиторий на GitHub. 
Иногда бывает так, что проект имеет несколько удаленных репозиториев – в таком случае каждому из них присваивается собственное имя. Главный репозиторий принято называть origin\

Теперь, когда у нас в локальном репозитории создан коммит и мы подключились к удаленному, можем отправить его на сервер. Мы это будем делать каждый раз, когда хотим обновить данные в удаленном репозитории.

Отправка коммита осуществляется с помощью команды push, которая имеет два параметра - имя удаленного репозитория (в нашем случае origin) и ветку, в которую необходимо внести изменения (master — это ветка по умолчанию для всех репозиториев).

Если у других пользователей возникла необходимость клонировать удаленный репозиторий, они могут получить полностью работоспособную копию при помощи команды clone:

$ git clone https://github.com/tutorialzine/awesome-project.git

GitHub автоматически создаст новый локальный репозиторий в виде удаленного на собственном сервере.

В случае, если другим пользователям нет необходимости делать клон удаленного репозитория, а нужно просто получить информацию об изменениях, это можно сделать с помощью команды pull.








