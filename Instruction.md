![photoGit](logo@2x.png) 

***Git - это бесплатная система управления версиями с открытым исходным кодом, предназначенная для быстрой и эффективной обработки любых проектов, от небольших до очень крупных.
Git прост в освоении и занимает небольшое пространство при молниеносной производительности. Он превосходит инструменты SCM, такие как Subversion, CVS, Perforce и ClearCase, благодаря таким функциям, как дешевое локальное разветвление, удобные промежуточные области и несколько рабочих процессов.***

# Работа с Git.

## 1. Наличие установленного Git
Прописать команду в терминале  `git --version` Если установлен то покажет версию. Иначе будет ошибка. 
## 2. Установка Git 
* 2.1 Устанавливаем актуальную версию с проверенного или же официального [сайта](https://git-scm.com/).  
Устанавливаем с настройками по умолчанию.
* 2.2 Так же можно воспользоваться Git и GitHub для начинающих и посмотреть [видео](https://www.youtube.com/watch?v=zZBiln_2FhM).
### 2.3 Настройка Git
При первом запуске необходимо представиться. Для этого понадобится ввсести 2 команды. 
```Bash
git config --global user.name "имя пользователя английскими буквами"
git config --global user.email — "email пользователя"
```
### 2.3 Инициализвация репозитория 
В терминале репозитория выбираем папку где хотим создать репозиторий. Пишем команду  
``` bash
git init 
```
В папке репозитория появится скрытая папка ```.git``` 

### Определение состояния
status — это еще одна важнейшая команда, которая показывает информацию о текущем состоянии репозитория: актуальна ли информация на нём, нет ли чего-то нового, что поменялось, и так далее. Запуск `git status` на нашем свеже созданном репозитории должен выдать:

```
$ git status
On branch master
Initial commit
Untracked files:
(use "git add ..." to include in what will be committed)
hello.txt
``````
### Подготовка файлов
 
В git есть концепция области подготовленных файлов. Можно представить ее как холст, на который наносят изменения, которые нужны в коммите. Сперва он пустой, но затем мы добавляем на него файлы (или части файлов, или даже одиночные строчки) командой `add` и, наконец, коммитим все нужное в репозиторий (создаем слепок нужного нам состояния) командой `commit`.\
В нашем случае у нас только один файл, так что добавим его:
``````
git add NAME
``````
Если нам нужно добавить все, что находится в директории, мы можем использовать
``````
git add -A
``````
Проверим статус снова, на этот раз мы должны получить другой ответ:\
``````BASH
git status
On branch master
Initial commit
Changes to be committed:
(use "git rm --cached ..." to unstage)
new file: NAME
``````
 для упрощения можно прописать 2 буквы названия и нажать кнопку Tab
 
 Так же для сохранения коммита нужно прописать 
```bash
git commit -m "коментарий что сделали или изменили".
```
### Как посмотреть коммиты
Для просмотра все выполненных фиксаций можно воспользоваться историей коммитов. Она содержит сведения о каждом проведенном коммите проекта. Запросить ее можно при помощи команды:\
```BASH
git log 
```
 
В ней содержится вся информация о каждом отдельном коммите, с указанием его хэша, автора, списка изменений и даты, когда они были сделаны.
Ну а если вдруг нам нужно переделать commit message и внести туда новый комментарий, можно написать следующую конструкцию:
``````BASH
git commit --amend -m 'Новый комментарий' 
``````
В данном случае сообщение последнего коммита перезапишется. Но злоупотреблять этим не стоит, поскольку эта операция опасная и лучше ее делать до отправки коммита на сервер.
### Возвращение файла к предыдущему состоянию
Гит позволяет вернуть выбранный файл к состоянию на момент определенного коммита. Это делается уже знакомой нам командой `checkout`, которую мы ранее использовали для переключения между ветками. \
Но она также может быть использована для переключения между коммитами (это довольно распространенная ситуация для Гита - использование одной команды для различных, на первый взгляд, слабо связанных задач).   
В следующем примере мы возьмем файл hello.txt и откатим все изменения, совершенные над ним к первому коммиту. Чтобы сделать это, мы подставим в команду идентификатор нужного коммита, а также путь до файла:
``````
 git checkout 09bd8cc1 hello.txt
 ``````
### Исправление коммита
Если вы опечатались в комментарии или забыли добавить файл и заметили это сразу после того, как закоммитили изменения, вы легко можете это поправить при помощи `commit —amend`. \
Эта команда добавит все из последнего коммита в область подготовленных файлов и попытается сделать новый коммит. Это дает вам возможность поправить комментарий или добавить недостающие файлы в область подготовленных файлов.\
Для более сложных исправлений, например, не в последнем коммите или если вы успели отправить изменения на сервер, нужно использовать revert.\
Эта команда создаст коммит, отменяющий изменения, совершенные в коммите с заданным идентификатором.
Самый последний коммит может быть доступен по алиасу HEAD:

`````` 
git revert HEAD
``````
Для остальных будем использовать идентификаторы:

```
git revert b10cc123
```
При отмене старых коммитов нужно быть готовым к тому, что возникнут конфликты. Такое случается, если файл был изменен еще одним, более новым коммитом. И теперь `git` не может найти строчки, состояние которых нужно откатить, так как они больше не существуют.

### Настройка .gitignore
В большинстве проектов есть файлы или целые директории, в которые мы не хотим (и, скорее всего, не захотим) коммитить. Мы можем удостовериться, что они случайно не попадут в `git add -A` при помощи файла ``.gitignore``\
Создайте вручную файл под названием ``.gitignore`` и сохраните его в директорию проекта.\
Внутри файла перечислите названия файлов/папок, которые нужно игнорировать, каждый с новой строки.\
Файл ``.gitignore`` должен быть добавлен, закоммичен и отправлен на сервер, как любой другой файл в проекте.
Вот хорошие примеры файлов, которые нужно игнорировать:

* Логи
* Артефакты систем сборки
* Папки node_modules в проектах node.js
* Папки, созданные IDE, например, Netbeans или IntelliJ
* Разнообразные заметки разработчика. \

Файл .gitignore, исключающий все перечисленное выше, будет выглядеть так:
``````
*.log
build/
node_modules/
.idea/
my_notes.txt
``````
Символ слэша в конце некоторых линий означает директорию (и тот факт, что мы рекурсивно игнорируем все ее содержимое). Звездочка, как обычно, означает шаблон.

### Игнорирование файлов
Зачастую нам не нужно, чтобы Git отслеживал все файлы в репозитории, потому что в их число могут входить:
файлы с чувствительной информацией вроде паролей;\
большие бинарные файлы;\
файлы сборок, которые генерируются после каждой компиляции;\
файлы, специфичные для ОС/IDE, например, .DS_Store для macOS или .iml для IntelliJ IDEA — нам нужно, чтобы репозиторий как можно меньше зависел от системы.\
Для игнорирования используется файл .gitignore.\
Чтобы отметить файлы, которые мы хотим игнорировать, можно использовать шаблоны поиска (считайте их упрощёнными регулярными выражениями):

 /___ — позволяет избежать рекурсивности — соответствует файлам только в текущей директории; \
__/ — соответствует всем файлам в указанной директории; \
*___ — соответствует всем файлам с указанным окончанием;\
! — игнорирование файлов, попадающих под указанный шаблон;\
[__] — соответствует любому символу из указанных в квадратных скобках;\
? — соответствует любому символу;   
/*\*/ — соответствует вложенным директориям, например a/**/d соответствует a/d, a/b/d, a/b/c/d и т. д. 

# Удаленные репозитории
Сейчас наш коммит является локальным — существует только в директории ``.git`` на нашей файловой системе. Несмотря на то, что сам по себе локальный репозиторий полезен, в большинстве случаев мы хотим поделиться нашей работой или доставить код на сервер, где он будет выполняться.

### 1. Что такое удаленный репозиторий
Репозиторий, хранящийся в облаке, на стороннем сервисе, специально созданном для работы с `git` имеет ряд преимуществ.\
 Во-первых - это своего рода резервная копия вашего проекта, предоставляющая возможность безболезненной работы в команде. А еще в таком репозитории можно пользоваться дополнительными возможностями хостинга. \
 К примеру -визуализацией истории или возможностью разрабатывать вашу программу непосредственно в веб-интерфейсе.
### Клонирование
Клонирование - это когда вы копируете удаленный репозиторий к себе на локальный ПК. Это то, с чего обычно начинается любой проект. При этом вы переносите себе все файлы и папки проекта, а также всю его историю с момента его создания. Чтобы склонировать проект, сперва, необходимо узнать где он расположен и скопировать ссылку на него.\
 В нашем руководстве мы будем использовать адрес https://github.com/tutorialzine/awesome-project, но вам посоветуем, попробовать создать свой репозиторий в GitHub, BitBucket или любом другом сервисе:
``````
git clone https://github.com/tutorialzine/awesome-project
``````
При клонировании в текущий каталог, там будет создана папка, в которую поместятся все проектные файлы и скрытая директория ``.git``, с самим репозиторием, или с необходимой информацией о нем. В такой ситуации, для клонируемого репозитория, по умолчанию, будет создана папка с одноименным названием, но его можно залить и в другую директорию, например:
``````
git clone https://github.com/tutorialzine/awesome-project new-folder
`````` 
### 2. Подключение к удаленному репозиторию
Чтобы загрузить что-нибудь в удаленный репозиторий, сначала нужно к нему подключиться. Регистрация и установка может занять время, но все подобные сервисы предоставляют хорошую документацию.\
Чтобы связать наш локальный репозиторий с репозиторием на GitHub, выполним следующую команду в терминале. \
`Обратите внимание, что нужно обязательно изменить URI репозитория на свой.`
```
# This is only an example. Replace the URI with your own repository address.
$ git remote add origin https://github.com/tutorialzine/awesome-project.git
```
Проект может иметь несколько удаленных репозиториев одновременно. Чтобы их различать, мы дадим им разные имена. Обычно главный репозиторий называется origin.

### 3. Отправка изменений на сервер
Сейчас самое время переслать наш локальный коммит на сервер. Этот процесс происходит каждый раз, когда мы хотим обновить данные в удаленном репозитории.
Команда, предназначенная для этого - push. Она принимает два параметра: имя удаленного репозитория (мы назвали наш origin) и ветку, в которую необходимо внести изменения (master — это ветка по умолчанию для всех репозиториев).
``````
$ git push origin master
Counting objects: 3, done.
Writing objects: 100% (3/3), 212 bytes | 0 bytes/s, done.
Total 3 (delta 0), reused 0 (delta 0)
To https://github.com/tutorialzine/awesome-project.git
* [new branch] master -> master
``````
Эта команда немного похожа на `git fetch`, с той лишь разницей, что при помощи fetch мы импортируем коммиты в локальную ветку, а применив push, мы экспортируем их из локальной в удаленную. Если вам необходимо настроить удаленную ветку используйте `git remote`.\
 Однако пушить надо осторожно, ведь рассматриваемая команда перезаписывает безвозвратно все изменения. В большинстве случаев, ее используют, чтобы опубликовать выгружаемые локальные изменения в центральный репозиторий. \
 А еще ее применяют для того, чтобы поделиться, внесенными в локальный репозиторий, нововведениями, с коллегами или другими удаленными участниками разработки проекта. Подытожив сказанное, можно назвать `git push - командой выгрузки, а git pull и git fetch - командами загрузки или скачивания`. После того как вы успешно запушили измененные данные, их необходимо внедрить или интегрировать, при помощи команды слияния `git merge`.\
В зависимости от сервиса, который вы используете, вам может потребоваться аутентифицироваться, чтобы изменения отправились. Если все сделано правильно, то когда вы посмотрите в удаленный репозиторий при помощи браузера, вы увидите файл hello.txt

### 4. Запрос изменений с сервера
Если вы сделали изменения в вашем удаленном репозитории, другие пользователи могут скачать изменения при помощи команды pull.
``````
$ git pull origin master
From https://github.com/tutorialzine/awesome-project
* branch master -> FETCH_HEAD
Already up-to-date.
``````
Так как новых коммитов с тех пор, как мы склонировали себе проект, не было, никаких изменений доступных для скачивания нет.

### Как удалить локальный репозиторий
Вам не понравился один из ваших локальных Git-репозиториев и вы хотите стереть его со своей машины. Для этого вам всего лишь надо удалить скрытую папку «.git» в корневом каталоге репозитория. Сделать это можно 3 способами:

1. Проще всего вручную удалить эту папку «.git» в корневом каталоге «Git Local Warehouse».
2. Также удалить, не устраивающий вас, репозиторий можно на github. Открываете нужный вам объект и переходите в пункт меню Настройки. Там, прокрутив ползунок вниз, вы попадете в зону опасности, где один из пунктов будет называться «удаление этого хранилища».
3. Последний метод удаления локального хранилища через командную строку, для этого в терминале необходимо ввести следующую команду:
``````
cd repository-path/
rm -r .git
``````
# Ветвление
Во время разработки новой функциональности считается хорошей практикой работать с копией оригинального проекта, которую называют веткой. Ветви имеют свою собственную историю и изолированные друг от друга изменения до тех пор, пока вы не решаете слить изменения вместе. Это происходит по набору причин:

Уже рабочая, стабильная версия кода сохраняется.\
Различные новые функции могут разрабатываться параллельно разными программистами.\
Разработчики могут работать с собственными ветками без риска, что кодовая база поменяется из-за чужих изменений.\
В случае сомнений, различные реализации одной и той же идеи могут быть разработаны в разных ветках и затем сравниваться.
### 1. Создание новой ветки
Основная ветка в каждом репозитории называется master. Чтобы создать еще одну ветку, используем команду branch <name>
``````
$ git branch amazing_new_feature
``````
Это создаст новую ветку, пока что точную копию ветки master.

### 2. Переключение между ветками
Сейчас, если мы запустим branch, мы увидим две доступные опции:
``````
$ git branch
amazing_new_feature
* master
``````
master — это активная ветка, она помечена звездочкой. Но мы хотим работать с нашей “новой потрясающей фичей”, так что нам понадобится переключиться на другую ветку.\
 Для этого воспользуемся командой checkout, она принимает один параметр — имя ветки, на которую необходимо переключиться.
``````
$ git checkout amazing_new_feature
``````
В Git ветка — это отдельная линия разработки. Git checkout позволяет нам переключаться как между удаленными, так и меду локальными ветками. Это один из способов получить доступ к работе коллеги или соавтора, обеспечивающий более высокую продуктивность совместной работы.\
 Однако тут надо помнить, что пока вы не закомитили изменения, вы не сможете переключиться на другую ветку. \
 В такой ситуации нужно либо сделать коммит, либо отложить его, при помощи команды `git stash`, добавляющей текущие незакоммиченные изменения в стек изменений и сбрасывающей рабочую копию до HEAD'а репозитория.

### 3. Слияние веток
Наша “потрясающая новая фича” будет еще одним текстовым файлом под названием feature.txt. Мы создадим его, добавим и закоммитим:
``````
$ git add feature.txt
$ git commit -m "New feature complete.”
``````
Изменения завершены, теперь мы можем переключиться обратно на ветку master.
``````
$ git checkout master
``````
Теперь, если мы откроем наш проект в файловом менеджере, мы не увидим файла feature.txt, потому что мы переключились обратно на ветку master, в которой такого файла не существует. Чтобы он появился, нужно воспользоваться merge для объединения веток (применения изменений из ветки `amazing_new_feature` к основной версии проекта).
``````
$ git merge amazing_new_feature
``````
Теперь ветка master актуальна. Ветка `amazing_new_feature` больше не нужна, и ее можно удалить.
``````
$ git branch -d awesome_new_feature
``````
Если хотите создать копию удаленного репозитория - используйте git clone. Однако если вам нужна только определенная его ветка, а не все хранилище - после git clone выполните следующую команду в соответствующем репозитории:
``````
git checkout -b <имя ветки> origin/<имя ветки>
``````
После этого, новая ветка создается на машине автоматически.

### Как удалять ветки в Git?
Бывают ситуации, когда после слива каких-то изменений из рабочей ветки в исходную версию проекта, ее, по правилам хорошего тона, необходимо удалить, чтобы она более не мешалась в вашем коде. Но как это сделать?
Для локально расположенных веток существует команда:
``````
git branch -d local_branch_name
``````

## 3. Основные команды 

![photo osnov git](gitinfo.png)

* `git init` - Позволяет проинициализировать репозиторий в текущей папке.   
* `git status` - Показывает текущий статус  
* `git add` - Отслеживает изменения файлов  
* `git add index.html` - добавляет index.html  
* `git add .` - добавляет все файлы  
* `git commit` - Сохраняет изменения в коммит  
* `git commit -m 'commit message'` — создает коммит сообщением  
* `git branch`- Работа с ветками в репозитории  
* `git branch` - показывает список веток  
* `git branch branch-name` — создает новую ветку       branch-name      
* `git branch -D branch-name` - удаляет ветку branch-name  
* `git checkout` - Переключается на другую ветку  
* `git checkout branch-name` - переключается на последний коммит в веткe branch-name
* `git checkout -b branch-name` - создает и переключается на ветку branch-name  
* `git merge`- Совмещает текущую ветку с выбранной  
* `git merge branch-name` - совмещает текущую ветку с branch-name  
* `git config` - Конфигурация и параметры git  
* `git config --global user.name` - Показывает имя пользователя  
* `git config --global user.name 'new user'` - Изменяет имя пользователя  
* `git config --global user.email` - Показывает email пользователя  
* `git config --global user.email 'test@mail.ru'` - Изменяет email пользователя  
* `git push` - Заливает текущие локальные коммиты в удаленный   репозиторий  
* `git pull` - Забирает изменения с удаленного репозитория в локальный    
* `git clone` - Клонирует проект с удаленного репозитория 
* `git commit --amend -m` - исправляет коментарий 
* `git commit --amend -am` - если еще были изменения 
* `git log --graph` - логи с визуфлизацией
## ![Синтаксис языка Marcdown](image.png) 
### Параграфы и разрывы строк (paragraphs and line breaks)
Чтобы поделить текст на параграфы, между ними нужно оставить пустую строку. Строка считается пустой, даже если в ней есть пробелы и табуляции. Если же строки находятся рядом, то они автоматически склеиваются в одну.
* поставить в конце строки два или больше пробела;  
* поставить в конце строки обратную косую черту `\`;
* использовать HTML-тег `<br>` .

`Обратите внимание, что у каждого из методов есть свои недостатки:
пробелы в конце строки бывает трудно заметить, и это может запутать читателя; обратный слеш вводится в стандарте CommonMark и может поддерживаться не всеми редакторами;
 HTML-теги в Markdown также поддерживаются не всеми редакторами.`

### Заголовки (headings) 
В синтаксисе Markdown есть шесть уровней заголовков: от H1 (самого большого) до H6 (самого маленького). Для их выделения используют решётки #, при этом есть несколько тонкостей:

* решётки можно ставить как перед заголовком, так и с двух сторон от него (на уровень заголовка влияют только те #, которые находятся перед ним);
* количество решёток соответствует уровню заголовка: одна для первого уровня, две для второго и так далее;
* между решёткой и текстом ставится пробел.
 
 ### Выделение текста (emphasis)
* Чтобы изменить начертание текста, нужно выделить его с двух сторон спецсимволами следующим образом: `<спецсимвол>текст<спецсимвол>`.

### Курсив (italic)
* Для выделения текста курсивом нужно использовать одну звёздочку `*`  или нижнее подчёркивание `_`.
### Жирный (bold)
* Для выделения текста жирным нужно использовать две звёздочки `**` или два нижних подчёркивания `__`.
### Жирный курсив (bold and italic)
* Для выделения текста сразу обоими стилями нужно использовать три звёздочки `***` или три нижних подчёркивания `___`.  

`Обратите внимание, что если вы хотите выделить фрагмент внутри слова, то это корректно сработает только при использовании звёздочек.`

### Зачёркнутый (strikethrough)
* Чтобы зачеркнуть текст, нужно использовать две тильды `~~`. Такая опция есть только в диалекте GitHub Flavored Markdown.

### Подчёркнутый (underline)
* В синтаксисе Markdown нет встроенного способа подчеркнуть текст. Но если ваш редактор поддерживает HTML, то можно использовать теги: `<u>Подчёркнутый текст</u>`

### Разделители (horizontal rules)
 * Чтобы оформить горизонтальный разделитель, нужно поставить три или больше специальных символа:звёздочки `*`, дефиса - или нижних подчёркивания `_`.  
Они должны находиться на отдельной строке, и между ними можно ставить любое количество пробелов и табуляций.  
Если ваш редактор поддерживает HTML-теги, то для разметки можно также использовать тег ``<hr>``.  
### Цитаты (blockquotes)
* Чтобы параграф отобразился как цитата, нужно поставить перед ним закрывающую угловую скобку `>`.  
>Внутрь одного блока цитаты можно поместить сразу несколько параграфов и использовать любые элементы оформления. Например, заголовки и другие цитаты. Чтобы сделать это, нужно поместить закрывающую угловую скобку перед началом каждой строки.      

### Списки (lists)
* В синтаксисе Markdown есть несколько видов списков. Для их оформления перед каждым пунктом нужно поставить подходящий тег и отделить его от текста пробелом.

### Нумерованные (ordered)
* Для создания нумерованного списка перед пунктами нужно поставить число с точкой. При этом нумерация в разметке ленивая. Неважно, какие именно числа вы напишете: Markdown пронумерует список автоматически.  

`Обратите внимание, что между двумя нумерованными списками, идущими подряд, нужно отбить две пустые строки. Если отбить только одну, то Markdown воспримет два списка как один. Некоторые редакторы в таком случае увеличивают интервал между пунктами.`

### Ненумерованные (unordered)
* Для создания ненумерованного списка нужно поставить перед каждым пунктом звёздочку `*`, дефис `-` или плюс `+`.
### Вложенные (nested)
* Чтобы создать вложенный список, нужно поставить перед его пунктами табуляцию или несколько пробелов. В Markdown одна табуляция соответствует четырём пробелам.
### Ссылки (links)
Самый лёгкий способ поместить ссылку в Markdown — заключить её в угловые скобки. Несмотря на простоту, он не является основным и был добавлен только в спецификации CommonMark.
* Чтобы оформить ссылкой часть текста, используется такой синтаксис: `[текст]без пробела  (ссылка)` . Можно сделать всплывающую подсказку при наведении курсора. Для этого в круглых скобках после ссылки нужно поставить пробел и написать текст подсказки в кавычках.

Ещё один способ оформить ссылку — справочный. Он работает как сноски в книгах: `[текст][имя сноски]`. При таком способе организации ссылок в конце документа нужно также написать и оформить саму сноску: [имя сноски]: ссылка. При желании после ссылки можно добавить подсказку — точно так же, как в предыдущем методе.  
Имя сноски может быть любым сочетанием символов: цифрами, буквами и даже знаками препинания. На одну и ту же сноску в тексте можно ссылаться сколько угодно раз.  
Ссылки, оформленные справочным методом, выглядят и работают точно так же, как и в предыдущем способе. Сами сноски в отформатированном документе не отображаются.
### Картинки (images)
Изображения в Markdown оформляются по принципу, схожему с принципом оформления ссылкок, только перед квадратными скобками нужно поставить восклицательный знак:
`![текст](путь к изображению)`. Здесь также можно сделать всплывающую подсказку.
### Вставка кода (code)
В Markdown есть несколько способов выделить исходный код:

Если надо отобразить фрагмент кода внутри строки с каким-то текстом, нужно с двух сторон выделить этот код одним или несколькими обратными апострофами ( ` ; их ещё называют бэктиками).
Чтобы выделить фрагмент из нескольких строк, нужно с двух сторон выделить его тремя обратными апострофами.
Также перед фрагментом кода можно поставить табуляцию или четыре пробела, при этом предыдущая строка должна быть пустой.
### Таблицы (tables)
В уже упомянутом выше диалекте GitHub Flavored Markdown (и некоторых других тоже) есть возможность оформлять таблицы. Столбцы разделяются вертикальными линиями `|`, а строка с шапкой отделяется от остальных дефисами `-`, которых можно ставить сколько угодно.
### Экранирование (escaping characters)
Многие символы в Markdown выполняют роль служебных. Если они встречаются в вашем тексте сами по себе, то для корректного отображения их стоит экранировать (иначе они просто не только не отобразятся сами, но и добавят вашему тексту какое-нибудь ненужное форматирование). Для этого перед ними ставится обратная косая черта \.  
Вот список символов, которые нужно экранировать:``` \`*_{}[]<>()#+-.! |.``` Делать это постоянно необязательно — достаточно ставить экран только в тех случаях, когда Markdown может воспринять эти символы как служебные. Например, если строка начинается с символа #, то экранировать её надо — потому что программа может решить, что вы хотите сделать заголовок. А вот если решётка находится где-то в центре строки, то экранировать ничего не надо — редактор поймёт, что тут она просто часть текста.

#### Синтаксис Markdown простой, гибкий и нетребовательный. У него есть несколько реализаций, благодаря которым в нём можно:
* выделять параграфы и переносить строки,
* оформлять заголовки,
* изменять начертание текста,
* ставить горизонтальные разделители,
* выделять цитаты,
* составлять списки,
* прикреплять ссылки,
* вставлять картинки и исходный код,
* делать таблицы. 
# Полезные документы для изучения Git:
### 1. С.Чакон, Б.Штрауб - Git для профессионального программиста (2016)
### 2. [Книга](https://git-scm.com/book/ru/v2) для изучения Git
