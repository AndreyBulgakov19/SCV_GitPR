# Работа с **Git**

![Logo](Image\git-logo-png-transparent.png)

## 1. Проверка наличия установленного **Git**
В терминале выполнить команду `git --version`.
Если Git установлен, появится сообщение с информацией о версии программы, иначе будет сообщение об ошибке.

## 2. Установка **Git**
Загружаем последнюю версию Git с [сайта](https://git-scm.com/downloads).
Устанавливаем с настройками по умолчанию.

## 3. Установка и настройка  **Visual Studio Code**

_Visual Studio Code_ - визуальный редактор исходного кода для многих языков программирования. VS Code - не единственный, но один из самых популярных редакторов. Именно в нём пишутся все команды Git.

Загружаем последнюю версию VS Code c [сайта](https://code.visualstudio.com/).
Устанавливаем настройки по умолчанию.

Для удобства можно установить русский язык. Для этого необходимо скачать доступное расширение. В магазине расширений (на панели слева нижний значок) в строке поиска набираем **Russian Language Pack** и устанавливаем данное расширение на свой ПК ![Рис.1](Image\Рис.1.jpg). После установки расширения необходимо перезагрузить VS Code, после чего вызваем строку поиска сочетанием клавиш **CTRL+Shift+P**. В появившейся строке после символа **>** начинаем набирать слово _Language_. ![Рис.2](Image\Рис.2.jpg). В выпадающем окне выбираем **Configure Display Language**. В открывшемся файле _locale.json_ меняем "en" на "ru" ![Рис.3](Image\Рис.3.jpg). После чего перезагружаем VS Code. Русский язык настроен.


## 4. Работа в Visual Studio Code
Все команды **Git** пишутся имеено в VS Code. Для этого необходимо вызвать **_Терминал_**.
Терминал можно вызвать несколькими способами: В верхнем меню нажимаем **Вид** в появившемся списке выбираем **Терминал** ![Рис.4](Image\Рис.4.jpg), либо вызываем Терминал сочетанием клавиш **Cntrl+`**.

Единовременно можно вызвать сразу несколько терминалов, для этого нужно нажать **_+_**, также можно выбрать модуль, например _Git bash_ или _PowerShell_ ![Рис.5](Image\Рис.5.jpg)

## 5. Настройка **Git**
При первом использовании Git необходимо представиться. Для
этого нужно ввести в терминале 2 команды:
```
git config --global user.name «Ваше имя английскими буквами» 
git config --global user.email ваша почта@example.com
```
## 6. Работа с **Git**. Основные команды **Git**

> Для того, чтобы инициализировать репозиторий необходимо в терминале ввести кманду **git init**

Для работы нам нужно создать в корне папки файл с расширением _.md_ (Markdown). Это можно сделать несколькими способами:

1. в Visual Studio Code рядом с корневой папкой нажимаем иконку "создать файл" ![Рис.6](Image\Рис.6.jpg); 

2. В верхнем меню нажимаем **_Файл_**, в появившемся списке выбираем **_Создать файл_**;

3. Создаёт новый файл сочетанием клавиш **_Cntr+Alt+Windows+N_**;

4. В поле _"Проводник"_ нажимаем правую клавишу мыши, в появившемся списке выбираем **_Создать файл_**.


> После создания файла откроется файл с пронумерованной первой строкой ![Рис.7](Image\Рис.7.jpg). В этом файле прописывается информация, но не команды!

> Чтобы записать изменения в репозиторий, необходимо ввести команду **git add**, после чего указать наименование файла, который записываем. Например, **_git add New_file.md_**. Можно воспомльзоваться командой **_git add ._**, что будет означать "записать всё".

> После записи необходимо создать коммит. Для этого вводим команду **_git commit -m "message"_**, где "message" где будет означать комментарий к коммиту, например **_git commit -m "Дополнили раздел 6"._**

> Команды **git add** и **_git commit -m "message"_** можно объединить командой **_git commit -am "message"_**. Например, **_git commit -am Дополнили раздел 6"._**

> Для того, чтобы проверить индексацию изменений и увидеть, какие файлы не отслеживаются **Git** необходимо воспользоваться командой **_git status_**. Данная команда отображает состояние рабочего каталога и раздела проиндексированных файлов.

> Команда **_git diff_** используется для вычисления разницы между любыми двумя **Git** деревьями. Это может быть, например, разница между вашей рабочей директорией и индексом.

В **Git** есть очень удобные лайфхаки.Для экономии времени с помощью клавиши **_Tab_** можно не набирать наименования файлов, комманд, веток, а набрать первые пару символов, продолжить этой клавишей. Также, если команды ранее вводились, их можно выбирать с помощью стрелочки **_"вверх"_** и **_"вниз"_**. Это позволять сэкономить дракоценное время.

В **Git** нужно постоянно сохраняться, набирая на клавиатуре **_Ctrl+S_**. Для того, чтобы не делать это постонянно, можно в верхней панели нажать **_Файл_** и прожать галочку на пункте **_Автосохранение_**. Таким образом, файл пересохраняется автоматически.

## 7. Работа с ветвлением в **Git**
Так как **Git** разработан для удобной и продуктивной работы сразу нескольких разработчиков, что позволяет не путаться в данных, была придумана система ветвления. По умолчанию существует лишь одна основная ветка. Она называется **_master_** или **_main_**.

> Для того, чтобы создать новую ветку необходимо набрать команду **_git branch_branchname_**, где branchname - это название ветки, которую создаём. Для того, чтобы посмотреть, в какой ветке находимся сейчас, необходимо набрать команду **_git branch_**. необходимая команда будет выделена **_*_**. ![Рис.8](Image\Рис.8.jpg). Также возле наименования папки в скопках указано, в какой ветке мы сейчас находимся.
> Для выбора необходимой ветки нужно вызвать команду **_git checkout branchname_**. В терминале пояится надпись _Switched to branch 'branchname'_, что будет означать, что мы перешли на нужную нам ветку. ![Рис.9](Image\Рис.9.jpg)

> После того, как все необходимые данные в ветке прописаны, записыны и создан коммит, необходимо слить всё в главную ветку **master (main)**. Для этого нужно перейти в ветку **master (main)** и задать комманду **_git merge_branchname_**, где branchname - наименование ветки, которую сливаем с основной веткой, после чего записываем и делаем коммит. ![Рис.10](Image\Рис.10.jpg)
> Иногда при слиянии веток случаются конфликты. Конфликт случаются не потому, что мы что-то сделали не так, а потому что ветка **master (main)** содержала в себе одни данные, а в ветке которой мы работали, мы добавили другие данные. Git попросит нас включиться и помочь ему в ручном режиме разобраться в данном вопросе. В поле, где мы пишем текст появится оба варианта и набор команд, из которых нужно будет выбрать нужную:_"Принять текущее изменение", "Принять входящее изменение", "Принять оба изменения", "Сравнить изменения"._ ![Рис.11](Image\Рис.11.jpg). Так, после выбора нужной команды в поле появятся необходимые данные. После чего нужно не забыть записать и сделать коммит.
> Если после слияния веток ветка, которую сливали больше не нужна, её можно удалить командой **_git branch -d branchname_**. ![Рис.12](Image\Рис.12.jpg)

## 8. Добавление изображений в **Git**
В **Git** есть возможность добавлять изображения. Для этого нужно воспользоваться простой конструкцией восклицательный знак, квадратные скобки, круглые скобки. В квадратных скобках мы пишем, как должна называться наше изображение, если изображение не сможет отображаться,а в круглых - относительный путь.![Рис.13](Image\Рис.13.jpg)    ![Рис.14](Image\Рис.14..jpg).

Сами изображения, которые мы хотим отобразить, необходимо загрузить в корень той же папки, где и лежит наш файл. Относительный путь можно получив, нахав в проводнике на изображение и выбрать **_"Скопировать относительный путь"_**.

## 9. Игнорирование файлов
Для того, чтобы исключить в репозитории из отслежывания определенные папки необходимо создать файл ***.gitignore***. В данном файле мы можем прописать отдельные файлы, папки, которые хотим игнорировать, либо разрешения файло(последние 4 символа вместе с точкой), если таковых у нас много. Напимер, теже самые изображения. В файле ***.gitignore*** с новой строки указываем .jpg, .png ![Рис.15](Image\Рис.15.jpg). На рисунке 15 видно, что те файлы, что мы заигнорировали, подсвечены серым, что означает из игнорирование **Git**, в то время как папка **Merge** подсвечена белым, так как не находится в игнорировании, но стоит нам скопировать относительный путь к ней и довать в файл ***.gitignore***, она сразу станет серой и начнёт игнорироваться как и остальные файлы, добавленные в ***.gitignore***. ![Рис.16](Image\Рис.16.jpg) Это нужно для того,чтобы **Git** не отслеживал "мусорные" файлы, которые отслеживать не нужно. После того, как в файл ***.gitignore*** добавили все игнорируе файлы, его необходимо записать (**_git add .gitignore_**).

## 10. История проекта в **Git**
В течение всего проекта, а также после его завершения можно просмотреть историю проекта. Это часто необходимо для того, чтобы узнать, кто и что сделал, выяснить, откуда появились баги, и отменить изменения, вызвавшие проблемы. Для того, чтобы воспользоваться этими данными, нужна возможность навигации по истории. Это возможно сделать с помощью команды **_git log_**. ![Рис.17](Image\Рис.17.jpg). После ввода данной команды в терминале отобразится вся история с обозначением номера коммита, даты создания и именем создателя. 

## 11. Перемещение между коммитами
**_Git_** позволяет переходить от коммита к коммиту,просматривая те или иные коммиты и данные в них. Для того, чтобы просмотреть мне коммиты, необходимо ввести команду **_git log--oneline_**. После данной команды в терминале появятся все коммиты ![Рис.18](Image\Рис.18.jpg). Переход в коммит задается командой **_git  checkout ......._**,  где вместо точек вводим номер коммита, например, на рис. 18 третий коммит снизу "Добавлены все изменения в раздел 6" соответстует номеру **_2f04019_**. Важно помнить, что для дальнейшей работы НЕОБХОДИМО вернуться в последний коммит. В противном случае, рискует потерять данные, которые будем вносить в наш файл. Для того, чтобы вернуться назад в последний коммит, вводим команду " **_git  checkout master_** ![Рис.19](Image\Рис.19.jpg). О том, что мы вернулись в последний коммит будет свидетельствовать надпись (master) в терминале перед вводом последующей команды.

# Работа с **GitHab**

## 12. Знакомство с **GitHab**. Создание учётной записи

**GitHab** - одна из платформ для обмена, хранения и распространения исходного кода, позволяющаая большому количеству разработчиков работать удалённо. **GitHab** достаточно популярен и используется такими компаниями, как _Microsoft_. Для работы в **GitHab** в первую очередь необходимо зайти на [официальный сайт](https://github.com/) создать новую учётную запись с использованием рабочей электронной почты. На указанную почту придёт письмо с просьбой подтверждения учётной записи и предоставлением кода для подтверждения ![Рис.20](Image\Рис.20.jpg). Обратите внимание, что кнопка **_Open GitHub_** подсвечена зелёным цветом🟢. В **GitHab** все кнопки дальнейших действий подсвечиваются зелёным, что позволяет без особых проблем интуитивно и безошибочно двигаться вперёд. После регистрации в **GitHab** можно настроить свой профиль, поменять аватар, указать различные данные о себе, например команию, где работает, веб-сайт, место жительства, социальные сети, либо просто рассказать о себе.

## 13. Создание удалённого репозитория

**GitHab** позволяет создать удалённый репозиторий на самой платформе. Для этого в верхнем правом углу необходимо нажать кнопку `➕`. Эта кнопка есть всегда, вне зависимости от того, в какой части сайта мы находимся.![Рис.21](Image\Рис.21.jpg). После нажатия на кнопку `➕` появится меню, в котором необходимо выбрать первый пункт **_new repository_**, после чего откроется страница, в которой будет необходимо написать наименование создаваемого репозитория.![Рис.22](Image\Рис.22.jpg). Если уже был создан локальный репозиторий на компьютере, то удалённый репозиторий лучше всего назвать также. Допустим, наша инструкция лежит в репозитории под названием **_Git_Education2023_**. Назовём удаленный репозиторий также. При создании удалённого репозитория кроме наименование можно добавить и описание репозитория. Кроме того, **GitHab** позволяет определить, будет ли репозиторий приватный или публичный, позволяет добавить лицензии и файлы **_.gitignore_**, что позволит не тратить время на подбор тех или иных файлов и расширений для игнорирования. Также **GitHab** предложит сразу создать **README file**, то есть текстовый файл, содержащий сведения о проекте. После того, как все параметры введены и выбраны, следует нажать зелёную кнопку `Create repository`. Удалённый репозиторий практически создан. Появится страница, описывающая дальнейшие данные. Предложено два варианта :

1. 
```
…or create a new repository on the command line
echo "# Git_Education2023" >> README.md
git init
git add README.md
git commit -m "first commit"
git branch -M main
git remote add origin https://github.com/Anna-Estrina/Git_Education2023.git
git push -u origin main
```

2. 
```
…or push an existing repository from the command line
git remote add origin <URL-адрес>
git branch -M main
git push -u origin main
```
Первый вариант предусматривает работу с нуля, то есть, когда ещё ничего не создано ни в удалённом, ни в локальном репозиториях. Иначе говоря, он напоминает, что нужно не забыть инициализироваться, создать первый коммит, создать файл (как раз предлагается создать файл **README**).

Второй вариант позволит привязать удалённый репозиторий к уже созданному локальному репозиторию.

## 14. Связывание локального и удалённого репозитория.
>В первую очередь со страницы удалённого репозитория копируем команду **_git remote add origin <URL-адрес>_**. В данной команде **_origin_** обозначает название пути, следующего за ним (<URL-адрес>).  Теперь наш локальный репозиторий связана с удалённым репозиторий.

>Команда **_git branch -M main_** переименовывает ветку **master** на **main**, так как в **GitHab** основная ветка названа **main**.

>Команда **_git push -u origin main_** отправляет изменения в локальном репозитории в удалённый репозиторий. ![Рис.23](Image\Рис.23.jpg). Важно, что **_-u origin main_** используется только самый первый раз. Далее для того, чтобы отправить изменения в удалённый репозиторий, нам достаточно вводить команду. Тут важно сказать, что вводить **_-u origin main_** требуется только в первый раз, далее чтобы отправить изменения в удалённый репозиторий достаточно ввести команду **_git push_** так как ветка отслеживается. Перед командой **_git push_** необходимо сделать коммит.

Команда **_git remote_** позволяет проверить есть ли связь. Если всё хорошо, после введения данной команды в терминале появится **origin**

Команда **_git remote -v_** позволяет получить более детальную информацию: пути для загрузки **(fetch)** и выгрузки **(push)** изменений.

В **GitHab** также можно редактировать текст. Данные изменения после завершения отправляются и в локальный репозиторий. Для редактирования необходимо рядом с файлом нажать на карандашик ![Рис.25](Image\Рис.25.jpg) и перейти в режим редактирования **Edit**. Также здесь есть режим просмотра **Prewiew**. Для наглядности, посмотрим как в  **GitHab** в режиме просмотра будет выглядеть код:

```C#
int number = Convert.ToInt32(Console.ReadLine()); 
if ((number % 7 == 0) && (number % 23 == 0))
{
    Console.WriteLine("Число делится и на 7, и на 23 одновременно");
}
else
{
    Console.WriteLine("Не делится на 7 или на 23 :(");
}
```
![Рис.26](Image\Рис.26.jpg)![Рис.27](Image\Рис.27.jpg)

После завершения редактирования файла необходимо вверху либо отменить все действия, нажав на кнопку `Cancel changes` , либо зафиксировать изменения, нажав на кнопку `Commit changes`![Рис.28](Image\Рис.28.jpg). После появится окно, где к коммиту нужно будет написать комментарий и описания, если таковое необходимо. По сути это такой же коммит, как и в локальном репозитории. 

## 15. Отправление данных в локальный репозиторий.

После того, как в удалённом репозитории все данные введены и закоммичены, их необходимо отправить в локальный репозиторий. Это позволяет сделать команда **_git pull_**. Важно, чтобы до отправки данных в локальном репозитории были закоммичены все изменеия, которые были внесены до момента редактирования в **GitHab**. Иначе будет ошибка и данные не прогрузятся. По своей сути команда **_git pull_** является составной командой команд **_git fetch_** и **_git merge_**. Если в локальном репозитории были данные, внесённые после отправки в удалённый репозиторий, после команды **_git pull_** может произойти конфликт, который решается как и при слиянии веток в ручном режиме ![Рис.29](Image\Рис.29.jpg)после чего необходимо сделать коммит.

## 16. Отправление данных в удалённый репозиторий

Чтобы отправить изменения в удалённый репозиторий достаточно ввести команду **_git push_**. Перед командой **_git push_** необходимо сделать коммит. **GitHab** позволяет просмотреть всю историю коммитов. для этого чуть выше карандашика нужно нажать **_History_**. Примечательно, что комманда **_git status_** будет показывать и то, что находится в удаленном репозитории, а также будет предлагать запушить недостающие данные из локального репозитория. 

Если в удаленном репозитории есть данные, не полученные в локальном репозитории, отправка из локального в удалённый репозиторий становится невозможной. Сначала нужно будет ввести комманду **_git pull_**, а потом **_git push_** и разрешить конфликты, если таковые появятся.

## 17. Работа с репозиториями других пользователей.

В связи со совей популярностью **GitHab** содержит в себе огромное количество проектов на разных языках. Это может быть полезно, так как много чего можно посмотреть, чему-то научиться. Посредством строки поиска можно найти тот или иной проект. Искать можно как и в самом **GitHab**, так и у пользователя, либо в репозитории. В найденном репозитории доступна вся информация: количество коммитов, когда сделан последний и т.д. Файл **README.md**.С проектом можно как ознакомиться в **GitHab**, так и копировать себе в локальный репозиторий. Для этого нажимаем сверху кнопку `Code` в появившемся окне выбираем вкладку **_Local_**далее - **_HTPPS_** и копируем URL-адрес ![Рис.30](Image\Рис.30.jpg). Далее идём в локальный репозиторий, открываем терминал корневой папки и прописываем команду **_git clone <Ccылка на репозиторий, котрый мы копировали>_**. После чего копия репозитория появляется в нашем локальном репозитории. После чего, наведясь на появившийся репозиторий, правой клавишей мыши вызываем меню, открываем во втроенном терминале и с помощью команды **_git log --graph_** можно посмотреть визуализированную историю проекта ![Рис.31](Image\Рис.31.jpg). С помощью команды **_git grep_** можно искать коммиты, например, по авторам, либо по датам и т.д..

## 18. Добавление изменений в чужой репозиторий

В проект можно внести свои предложения, свой вклад. Прежде чем производить какие-то взаимодействия с чужим репозиторием, необходимо сделать **Fork** в своём аккаунте. Для этого, находясь внутри определенного репозитория пользователя" нужно прожать соответствующую кнопку `Fork` ![Рис.32](Image\Рис.32.jpg). В противном случае, все изменения, которые вы хотите произвести будут не возможны. После Форка открывается страница **_Create a new fork_** ![Рис.33](Image\Рис.33.jpg). **GitHab** предложит ввести имя репозитория, но по умолчанию используется то имя, которое использовано и у владельца репозитория. Находясь в своей учётной записи, мы видим репозиторий, который зафоркали, а также видим, откуда мы его зафоркали. ![Рис.34](Image\Рис.34.jpg). Далее также клонируем в корневую папку, как клонировали свой. Важно, что репозиторий в репозиторий добавлять КРАЙНЕ НЕЖЕЛАТЕЛЬНО!!!

При клонировании можно поменять имя репозитория, для этого вместо используемого имени в команде **_git clone_** пишем то, что нам нужно. 

Для того, чтобы вносить изменения, мы также наводимся на созданную папку, создаём встроенный терминал и работает. Все изменения, которые мы будем вносить попадают не сразу в удалённый репозиторий как принятый текст, а приходят владельцу как предложения внести ту или иную информацию в проект и требуют его согласования. 

Если Fork сделан ошибочно, можно удалить его. Для этого нужно зайти в своей учётной записи зайти в данный репозиторий, далее в настройках (Setting) в самом низу выбрать `Delite this repository`, после чего в появившемся поле ввести имя своей учетной записи и через слэш имя репозитория ![Рис.35](Image\Рис.35.jpg), далее прожать `Delite this repository` и ввести пароль. Такое количество проверок связано с тем, что репозиторий, который был удален не восстановить.

Поэтому все изменения делаются в других ветках. Ветки создаются также как и при работе с локальным терминалом. Например, создаём ветку **new**. Можно создавать новые файлы. Если такой ветки не было, то после команды **_git push_** и обновления страницы в **GitHab** может ничего не появиться. Это будет связано с тем, что в удалённом репозитории ветки с таким наименованием не было.В этом случае **Git** нам предложит ввести команду **_git push --set-upstream origin new_**. " Эта команда создаст в удалённом репозитории ветку **new** ![Рис.36](Image\Рис.36..jpg), которую можно будет проверить в список веток. Далее идём во вкладку **Pull reqest** и уже в данной вкладке выбираем необходимую ветку **new**, после чего **GitHab** сравнит данные в репозиториях и при отсутствии конфликта предложит сделать `Create Pull reqest`. Далее открывается окно, где по умолчанию **GitHab** добавляет последний коммит. На самом деле, это Заголовок Pull reqest. Заголовок можно поменять, можно добавить описание, после чего нужно прожать кнопку `Create Pull reqest`, после чего поятся надпись **_This branch has no conflicts with the base branch".

После того, как мы добавили свои дополнения, у владельца репозитоия появляется возможность просмотреть те изменения, которые мы предлагаем, принять, попросить доработать(либо другой комментарий), либо отклонить. Для правильной работы **GitHab** предлагает список команд для работы ![рис.37](Image\Рис.37.jpg). отметим, что слияние всегда происходят в ветку main 
