# Инструкция для работы с Git и удаленными репозиториями

## Что такое Git?
Git — это набор консольных утилит, которые отслеживают и фиксируют изменения в файлах (чаще всего речь идет об исходном коде программ, но вы можете использовать его для любых файлов на ваш вкус). Изначально Git был создан Линусом Торвальдсом при разработке ядра Linux. Однако инструмент так понравился разработчикам, что в последствии, он получил широкое распространение и его стали использовать в других проектах. С его помощью вы можете сравнивать, анализировать, редактировать, сливать изменения и возвращаться назад к последнему сохранению. Этот процесс называется контролем версий.
Git - это одна из реализаций распределенных систем контроля версий, имеющая как и локальные, так и удаленные репозитории. Одна из самых популярных реализаций систем контроля в мире.

## 1. Проверка наличия установленного Git
В терминале выполнить команды `git --version`
Если Git установлен появится сообщение с информацией о версии программы, иначе будет сообщение о ошибке. 

## 2. Установка Git
Загружаем Git с [сайта](https://git-scm.com/downloads). Устанавливаем с настройками по умолчанию.
## 3. Настройка Git
При первом использовании Git необходимо представиться.
Для этого нужно ввести в терминале 2 команды:
```
git config --global user.name «Ваше имя английскими буквами»
git config --global user.email ваша почта@example.com
```
## 4. Подготовка репозитория
Для того, чтобы посмотреть все настройки системы, использовать команду:
**git config --list**

Git хранит свои файлы и историю прямо в папке проекта. Чтобы создать новый репозиторий, нам нужно открыть терминал, зайти в папку нашего проекта и выполнить команду **git init**. Это включит приложение в этой конкретной папке и создаст скрытую директорию .git, где будет храниться история репозитория и настройки.
Например, создать на рабочем столе папку под названием git_exercise. Для этого в окне терминала ввести:
```
mkdir Desktop/git_exercise
cd Desktop/git_exercise
git init
```
Ответ терминала:
```
Initialized empty Git repository in /home/user/Desktop/git_exercise/.git/
```
Это значит, что наш репозиторий был успешно создан, но пока что пуст. Теперь можно создать  файл  и сохраните его в директории git_exercise для отслеживания версий.
## 5. Определение состояния
**status** — это еще одна важнейшая команда, которая показывает информацию о текущем состоянии репозитория: актуальна ли информация на нём, нет ли чего-то нового, что поменялось, и так далее. Запуск git status на нашем свежесозданном репозитории должен выдать:
```
$ git status
On branch master
Initial commit
Untracked files:
(use "git add ..." to include in what will be committed)
hello.txt
```
Сообщение говорит о том, что файл hello.txt неотслеживаемый. Это значит, что файл новый и система еще не знает, нужно ли следить за изменениями в файле или его можно просто игнорировать. Для того, чтобы начать отслеживать новый файл, нужно его специальным образом объявить.

## 6. Подготовка файлов
В git есть концепция области подготовленных файлов. Можно представить ее как холст, на который наносят изменения, которые нужны в коммите. Сперва он пустой, но затем мы добавляем на него файлы (или части файлов, или даже одиночные строчки) командой add и, наконец, коммитим все нужное в репозиторий (создаем слепок нужного нам состояния) командой **commit**.
В нашем случае у нас только один файл, так что добавим его:

**git add GitInstruction.md**

Если нам нужно добавить все, что находится в директории, мы можем использовать

**git add -A**
Проверим статус снова, на этот раз мы должны получить другой ответ:
```
$ git status
On branch master
Initial commit
Changes to be committed:
(use "git rm --cached ..." to unstage)
new file: hello.txt
```
Файл готов к коммиту. Сообщение о состоянии также говорит нам о том, какие изменения относительно файла были проведены в области подготовки — в данном случае это новый файл, но файлы могут быть модифицированы или удалены.

## 7. Фиксация изменений
Как сделать коммит.
Представим, что нам нужно добавить пару новых блоков в GitInstruction.md. Для сохранения изменений, их необходимо закоммитить. Но сначала, мы должны обозначить этот файл для Гита, при помощи команды git add, добавляющей (или подготавливающей) его к коммиту. Добавлять файлы можно по отдельности:
```
git add GitInstruction.md
git add hello_w.md

```
или вместе - всё сразу:
```
git add .
```
Конечно добавлять всё сразу удобнее, чем прописывать каждую позицию отдельно. Однако, тут надо быть внимательным, чтобы не добавить по ошибке ненужные элементы. Если же такое произошло изъять оттуда ошибочный файл можно при помощи команды

git reset:
git reset Markdown_logo.png

## 8. Создание коммита

```
git commit -m 'Add some code'
```
Флажок -m задаст commit message - комментарий разработчика. Он необходим для описания закоммиченных изменений. И здесь работает золотое правило всех комментариев в коде: «Максимально ясно, просто и содержательно обозначь написанное!»

```
git commit -am 'Add some code'
```
Сразу добавляет и заносит commit

## 9. Как посмотреть коммиты
Для просмотра все выполненных фиксаций можно воспользоваться историей коммитов. Она содержит сведения о каждом проведенном коммите проекта. Запросить ее можно при помощи команды:
```
git log - все коммиты

git log --graph - все коммиты в графическом виде

git log --graph --oneline - все коммиты в графическом виде сокращенный вариант
```
В ней содержится вся информация о каждом отдельном коммите, с указанием его хэша, автора, списка изменений и даты, когда они были сделаны. Отследить интересующие вас операции в списке изменений, можно по хэшу коммита, при помощи команды git show :
```
git show hash_commit
```
Ну а если вдруг нам нужно переделать commit message и внести туда новый комментарий, можно написать следующую конструкцию:

**git commit --amend -m 'Новый комментарий'**

В данном случае сообщение последнего коммита перезапишется. Но злоупотреблять этим не стоит, поскольку эта операция опасная и лучше ее делать до отправки коммита на сервер.
## Отслеживание изменений, сделанных в коммитах
У каждого коммита есть свой уникальный идентификатор в виде строки цифр и букв. Чтобы просмотреть список всех коммитов и их идентификаторов, можно использовать команду log:

```
$ git log
commit ba25c0ff30e1b2f0259157b42b9f8f5d174d80d7
Author: Tutorialzine
Date: Mon May 30 17:15:28 2016 +0300
New feature complete
commit b10cc1238e355c02a044ef9f9860811ff605c9b4
Author: Tutorialzine
Date: Mon May 30 16:30:04 2016 +0300
Added content to hello.txt
commit 09bd8cc171d7084e78e4d118a2346b7487dca059
Author: Tutorialzine
Date: Sat May 28 17:52:14 2016 +0300
Initial commit
```
Как можно заметить, идентификаторы довольно длинные, но для работы с ними не обязательно копировать их целиком — первых нескольких символов будет вполне достаточно. Чтобы посмотреть, что нового появилось в коммите, мы можем воспользоваться командой show [commit]

```
$ git show b10cc123
commit b10cc1238e355c02a044ef9f9860811ff605c9b4
Author: Tutorialzine
Date: Mon May 30 16:30:04 2016 +0300
Added content to hello.txt
diff --git a/hello.txt b/hello.txt
index e69de29..b546a21 100644
--- a/hello.txt
+++ b/hello.txt
@@ -0,0 +1 @@
+Nice weather today, isn't it?
```
Чтобы увидеть разницу между двумя коммитами, используется команда diff (с указанием промежутка между коммитами):
```
$ git diff 09bd8cc..ba25c0ff
diff --git a/feature.txt b/feature.txt
new file mode 100644
index 0000000..e69de29
diff --git a/hello.txt b/hello.txt
index e69de29..b546a21 100644
--- a/hello.txt
+++ b/hello.txt
@@ -0,0 +1 @@
+Nice weather today, isn't it?
```
## Возвращение файла к предыдущему состоянию
Гит позволяет вернуть выбранный файл к состоянию на момент определенного коммита. Это делается уже знакомой нам командой checkout, которую мы ранее использовали для переключения между ветками. Но она также может быть использована для переключения между коммитами (это довольно распространенная ситуация для Гита - использование одной команды для различных, на первый взгляд, слабо связанных задач).
В следующем примере мы возьмем файл hello.txt и откатим все изменения, совершенные над ним к первому коммиту. Чтобы сделать это, мы подставим в команду идентификатор нужного коммита, а также путь до файла:
```
$ git checkout 09bd8cc1 hello.txt
```

# 10. Ветвление
Во время разработки новой функциональности считается хорошей практикой работать с копией оригинального проекта, которую называют веткой. Ветви имеют свою собственную историю и изолированные друг от друга изменения до тех пор, пока вы не решаете слить изменения вместе. Это происходит по набору причин:

* Уже рабочая, стабильная версия кода сохраняется.
* Различные новые функции могут разрабатываться параллельно разными программистами.
* Разработчики могут работать с собственными ветками без риска, что кодовая база поменяется из-за чужих изменений.
* В случае сомнений, различные реализации одной и той же идеи могут быть разработаны в разных ветках и затем сравниваться.

## Создание новой ветки
Основная ветка в каждом репозитории называется master. Чтобы создать еще одну ветку, используем команду branch <name>
```
git branch amazing_new_feature
```
Это создаст новую ветку, пока что точную копию ветки master.

```
git checkout -b branch_name 
git swith -c branch_name
```
Создает новую ветку и сразу переключается на неё

## Переключение между ветками
Сейчас, если мы запустим branch, мы увидим две доступные опции:
```
git branch
amazing_new_feature
* master
```
master — это активная ветка, она помечена звездочкой. Но мы хотим работать с нашей “новой потрясающей фичей”, так что нам понадобится переключиться на другую ветку. Для этого воспользуемся командой checkout, она принимает один параметр — имя ветки, на которую необходимо переключиться.
```
git checkout amazing_new_feature
либо git swith amazing_new_feature
```
В Git ветка — это отдельная линия разработки. Git checkout позволяет нам переключаться как между ветками. Это один из способов получить доступ к работе коллеги или соавтора, обеспечивающий более высокую продуктивность совместной работы. 

## 11. Слияние веток
Наша новая ветка будет текстовым файлом под названием feature.txt. Мы создадим его, добавим и закоммитим:
```
git add feature.txt
git commit -m "New feature complete.”
```
Изменения завершены, теперь мы можем переключиться обратно на ветку master.
```
git checkout master
```
Теперь, если мы откроем наш проект в файловом менеджере, мы не увидим файла feature.txt, потому что мы переключились обратно на ветку master, в которой такого файла не существует. Чтобы он появился, нужно воспользоваться merge для объединения веток (применения изменений из ветки amazing_new_feature к основной версии проекта).
```
git merge amazing_new_feature
```
Теперь ветка master актуальна. Ветка amazing_new_feature больше не нужна, и ее можно удалить.
```
git branch -d awesome_new_feature
```


## 12. Как удалять ветки в Git?
Бывают ситуации, когда после слива каких-то изменений из рабочей ветки в исходную версию проекта, ее, по правилам хорошего тона, необходимо удалить, чтобы она более не мешалась в вашем коде. Но как это сделать?
Для локально расположенных веток существует команда:
```
git branch -d branch_name
```
где флажок -d являющийся опцией команды git branch - это сокращенная версия ключевого слова --delete, предназначенного для удаления ветки, а local_branch_name – название ненужной нам ветки.
Однако тут есть нюанс: удалить текущую ветку, в которую вы, в данный момент просматриваете - нельзя. Если же вы все-таки попытаетесь это сделать, система отругает вас и выдаст ошибку с таким содержанием:
```
Error: Cannot delete branch local_branch_name checked out at название_директории
```
Так что при удалении ветвей, обязательно переключитесь на другой branch.

Удалить незалитую ветку можно командой:

```
git branch -D branch_name
```

## 13. Настройка .gitignore
В большинстве проектов есть файлы или целые директории, в которые мы не хотим (и, скорее всего, не захотим) коммитить. Мы можем удостовериться, что они случайно не попадут в git add -A при помощи файла .gitignore

Создайте вручную файл под названием .gitignore и сохраните его в директорию проекта.
Внутри файла перечислите названия файлов/папок, которые нужно игнорировать, каждый с новой строки.
Файл .gitignore должен быть добавлен, закоммичен и отправлен на сервер, как любой другой файл в проекте.
Вот хорошие примеры файлов, которые нужно игнорировать:

Логи
Артефакты систем сборки
Папки node_modules в проектах node.js
Папки, созданные IDE, например, Netbeans или IntelliJ
Разнообразные заметки разработчика.
Файл .gitignore, исключающий все перечисленное выше, будет выглядеть так:
```
*.log
build/
node_modules/
.idea/
my_notes.txt
```
Символ слэша в конце некоторых линий означает директорию (и тот факт, что мы рекурсивно игнорируем все ее содержимое). Звездочка, как обычно, означает шаблон.
В наш .gitignore добавлен файл Markdown_logo.png. Неотслеживаемые файлы серые.

# 14. Удаленные репозитории
Сейчас наш коммит является локальным — существует только в директории .git на нашей файловой системе. Несмотря на то, что сам по себе локальный репозиторий полезен, в большинстве случаев мы хотим поделиться нашей работой или доставить код на сервер, где он будет выполняться.
## Git vs GitHub
Но если захотим работать так же, как те, кто придумывал системы контроля версий,
потребуется воспользоваться удалёнными репозиториями. И здесь мы впервые встретимся с сервисом GitHub. Надо понимать и чётко осознавать, что Git и GitHub — разные вещи.
1. Git — это программа, которая устанавливается на компьютер, где локально выполняет
указанные вами команды.
2. GitHub — это сервис компании Microsoft, который позволяет интегрироваться с
программой Git и настроить удалённую работу с вашим репозиторием.
## Что такое удаленный репозиторий
Репозиторий, хранящийся в облаке, на стороннем сервисе, специально созданном для работы с git имеет ряд преимуществ. Во-первых - это своего рода резервная копия вашего проекта, предоставляющая возможность безболезненной работы в команде. А еще в таком репозитории можно пользоваться дополнительными возможностями хостинга. К примеру -визуализацией истории или возможностью разрабатывать вашу программу непосредственно в веб-интерфейсе.
## Клонирование
Для начала создадим папку на нашем рабочем столе. Назовём её Lesson 3 и откроем в редакторе VS Code. Так как в нашей папке мы не создавали репозиторий, то если вызвать команду git status появитсяь надпись, что это не Git-репозиторий, возникла какая-то фатальная ошибка, и наша программа отказывается работать дальше. То есть мы убедились, что здесь лежит пустая папка без каких-либо репозиториев.

Перейдём на сайт github.com. Ищем репозиторий который мы хотим клонировать. Жмем на зелёную кнопка Code. Под HTTS копируем строку с адресом. В терминале пишем:

```
git clone https://github.com/ilnar-geekbrains/version_control_lection_3
```

После этого Git скопирует репозиторий, находящийся на сервисе GitHub, в наш Внутри папки Lesson 3 появилась новая папка с именем version_control_lection_3. То есть Git скачал репозиторий, который находился на GitHub, создал папку с таким же названием и поместил всё, что находилось в репозитории. Обратите внимание, внутри этой папки есть файл .gitignore и файл Markdown instruction.md. Именно эти файлы находились в нашем репозитории на сайте GitHub.
Для того чтобы работать с файлами локально необходимо переместиться в директорию репозитория 
```
cd — change directory — поменять директорию
```
По факту у нас появляется полная копия представленной работы, будто мы делали её
самостоятельно. Мы можем продолжить работу с этим файлом, и у нас появится собственная версия репозитория. Однако всё происходит
локально и с версией которая находится на GitHub наша не связанна.

## Как разместить свой дипозиторий на GitHub
Создаем локальный депозитарий на своем компьютере:
```
git init
```
Создаем какой-нибудь файл. Добавляем файл и делаем commit:
```
get add Hello.md
get commit -m "Inishial commit"
```

Переходим на GitHub. Справа верху + , нажимаем и создаём новый репозиторий. GitHub предлагает три варианта:
```
…or create a new repository on the command line
echo "# GitInstruction" >> README.md
git init
git add README.md
git commit -m "first commit"
git branch -M main
git remote add origin https://github.com/Velocatcher/GitInstruction.git
git push -u origin main


…or push an existing repository from the command line
git remote add origin https://github.com/Velocatcher/GitInstruction.git
git branch -M main
git push -u origin main


…or import code from another repository
You can initialize this repository with code from a Subversion, Mercurial, or TFS project.

<Import code>
```
У нас уже есть локальный репозиторий, поэтому выбираем второй способ.
1. **git remote**- связываем наш локальный репозиторий с удалённым

2. **git branch** -M main - указываем какая ветка будет основной

3. **git push** - направляем информацию из локального репозитория в удалённый

При первой попытки сделать puch необходимо сделать авторизацию с GitHub.
Теперь если необходимо передать кому-либо репозиторий скидываем ссылку в кнопке Code. Репозиторий должен быть публичный.

При внесении изменений в удаленный репозиторий с другого компьютера локальная версия на нашем компьютере становится не актуальной.
Воодим команду
```
git pull
```
Необходимо обратить внимание, что pull составная команда, она не только скачает все обновления, но и попытается смёржить все ветки.



## Работа с удаленными репозиториями в git

При работе с удаленным репозиторием в реале доступ к нему есть у очень ограниченного числа лиц. Чтобы вносить изменения в чужой репозиторий:


● Делаем fork репозитория - свою копию данного репозитория на своём аккаунте.

● Делаем clone СВОЕЙ версии репозитория на локальный компьютер

● Изменения в чей-то проект ВСЕГДА делаются в отдельной ветке! Смотрим какие ветки существуют get branch и cоздаем свою новую ветку get branch new_branch, git checkout new_branch и в НЕЕ вносим свои изменения.
README.md всегда называют капсом.

● Фиксируем изменения (делаем коммиты)

● Отправляем свою версию в свой GitHub , git push
Обновляем, появляется кнопка **Compare&pull request**
При нажатии появляется окно с описанием добавления и кнопкой **Create pull request**
Если кнопка не появилась переходим во вкладку Pull requests (слева вверху вторая). Нажимаем на зелёную кнопку **New pull requests**. В заголовке справа выбираем нужную ветку для сравнения. Появляется кнопка  **Create pull request**. Пошел делать домашку :)


