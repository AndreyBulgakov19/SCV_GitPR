<img src="Git.png" alt="drawing" width="300"/>

# Работа с Git и Github
## 1. Проверка наличия установленного Git
В терминале выполнить команду ***`git --version`***
Если Git установлен, то появится сообщение о текущей версии программы, иначе, будет получено сообщение об ошибке.
## 2. Установка Git
Загружаем последнюю версию Git с [сайта](https://github.com/git-guides/install-git)
Устанавливаем с настройками по умолчанияю
## 3. Настройка Git
При первом использовании Git необходимо представиться. Для
этого нужно ввести в терминале 2 команды:
```
git config --global user.name «Ваше имя английскими буквами» 
git config --global user.email ваша почта@example.com
```
## 4. Инициализация репозитория
Для создания нового репозитория используется команда ***`git init.`*** Команду ***`git init`*** выполняют только один раз для первоначальной настройки нового репозитория, при этом директория может содержать файлы проекта, так и может быть пустой.
Тут следует обратить внимание на несколько важных вещей:
* По умолчанию `git` создаёт ветку `master`, где будут размещаться коммиты. В gitHUB же дефолтная ветка называется `main` — несоответствие веток может привести к проблемам в будущем, лучше сразу переименовать ветку `master` в `main`;
* Задать имя дефолтной ветки можно с помощью команды 
```
git config --global init.defaultBranch main
```
 где `main` — название ветки. Эта команда работает до создания первого коммита;
* Переименовать уже существующую ветку можно командой
```
git branch -m [название ветки].
```
При инициализации репозитория в директории проекта будет создана скрытая поддиректория **.git**, которая содержит различные сущности **git** и информацию о репозитории.
## 5. Запись изменений в репозиторий
Каждый файл в вашем рабочем каталоге может находиться в одном из двух состояний: 
* под версионным контролем - *отслеживаемые*
* неотслеживаемые

*Отслеживаемые файлы* — это те файлы, которые были в последнем снимке состояния проекта; они могут быть неизменёнными, изменёнными или подготовленными к коммиту. Если кратко, то отслеживаемые файлы — это те файлы, о которых знает Git.

*Неотслеживаемые файлы* — это всё остальное, любые файлы в вашем рабочем каталоге, которые не входили в ваш последний снимок состояния и не подготовлены к коммиту. Когда вы впервые клонируете репозиторий, все файлы будут отслеживаемыми и неизменёнными, потому что Git только что их извлек и вы ничего пока не редактировали.
### Определение состояния файлов
Основной инструмент, используемый для определения, какие файлы в каком состоянии находятся – это команда *git status*. Если вы выполните эту команду сразу после клонирования, вы увидите что-то вроде этого:
```python
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
nothing to commit, working tree clean
```
Это означает, что у вас чистый рабочий каталог; другими словами – в нем нет отслеживаемых измененных файлов. Git также не обнаружил неотслеживаемых файлов, в противном случае они бы были здесь перечислены. Наконец, эта команда сообщает вам, в какой ветке вы находитесь, и что она не расходится с веткой на сервере. Пока что это всегда ветка master, ветка по умолчанию;

Предположим, вы добавили в свой проект новый файл, простой файл README. Если этого файла раньше не было, и вы выполните `git status`, вы увидите свой неотслеживаемый файл так:
```python
$ echo 'My Project' > README
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Untracked files:
  (use "git add <file>..." to include in what will be committed)

    README

nothing added to commit but untracked files present (use "git add" to track)
```
Понять, что этот новый файл *README* неотслеживаемый можно по тому, что он находится в секции `«Untracked files»` в выводе команды *status*. Статус *Untracked* означает, что Git видит файл, которого не было в предыдущем снимке состояния (коммите); Git не станет добавлять его в ваши коммиты, пока вы его явно об этом не попросите. Это предохранит вас от случайного добавления в репозиторий сгенерированных бинарных файлов или каких-либо других, которые вы и не думали добавлять. Но мы хотели добавить *README**, так давайте сделаем это.

Отслеживание новых файлов
Для того чтобы начать отслеживать (добавить под версионный контроль) новый файл, используется команда `git add`. Чтобы начать отслеживание файла README, вы можете выполнить следующее:
```python
$ git add README
```
Если вы снова выполните команду *status*, то увидите, что файл *README* теперь отслеживаемый и добавлен в индекс:
```python
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)

    new file:   README
```
Вы можете видеть, что файл проиндексирован, так как он находится в секции *«Changes to be committed»*. Если вы выполните коммит в этот момент, то версия файла, существовавшая на момент выполнения вами команды `git add`, будет добавлена в историю снимков состояния. Как вы помните, когда вы ранее выполнили `git init`, затем вы выполнили `git add` (файлы) – это было сделано для того, чтобы добавить файлы в вашем каталоге под версионный контроль. Команда `git add` принимает параметром путь к файлу или каталогу; если это каталог, команда рекурсивно добавляет все файлы из указанного каталога в индекс.

## Индексация изменённых файлов
Давайте изменим файл, уже находящийся под версионным контролем. Если вы измените отслеживаемый файл *CONTRIBUTING.md* и после этого снова выполните команду `git status`, то результат будет примерно следующим:
```python
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    new file:   README

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   CONTRIBUTING.md
```
Файл *CONTRIBUTING.md* находится в секции *«Changes not staged for commit»* – это означает, что в рабочем каталоге отслеживаемый файл был изменён, но пока не проиндексирован. Чтобы проиндексировать его, необходимо выполнить команду `git add`. Это многофункциональная команда, она используется для добавления под версионный контроль новых файлов, для индексации изменений, а также для других целей, например для указания файлов с исправленным конфликтом слияния. Вам может быть понятнее, если будете думать об этой команде как «добавить этот контент в следующий коммит», а не как «добавить этот файл в проект». Выполним `git add`, чтобы проиндексировать *CONTRIBUTING.md*, а затем снова выполним `git status:`
```python
$ git add CONTRIBUTING.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    new file:   README
    modified:   CONTRIBUTING.md
```
Теперь оба файла проиндексированы и войдут в следующий коммит. В этот момент вы, предположим, вспомнили одно небольшое изменение, которое хотели бы сделать в *CONTRIBUTING.md* до коммита. Вы открываете файл, вносите и сохраняете необходимые изменения и вроде бы готовы к коммиту. Но давайте-ка ещё раз выполним `git status`:
```python
$ vim CONTRIBUTING.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    new file:   README
    modified:   CONTRIBUTING.md

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   CONTRIBUTING.md
```
Что за чёрт? Теперь *CONTRIBUTING.md* отображается как проиндексированный и непроиндексированный одновременно. Как такое возможно? Такая ситуация наглядно демонстрирует, что Git индексирует файл в точности в том состоянии, в котором он находился, когда вы выполнили команду `git add`. Если вы выполните коммит сейчас, то файл *CONTRIBUTING.md* попадёт в коммит в том состоянии, в котором он находился, когда вы последний раз выполняли команду `git add`, а не в том, в котором он находится в вашем рабочем каталоге в момент выполнения `git commit`. Если вы изменили файл после выполнения `git add`, вам придётся снова выполнить `git add`, чтобы проиндексировать последнюю версию файла:
```python
$ git add CONTRIBUTING.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    new file:   README
    modified:   CONTRIBUTING.md
```
Более подробнее с тематикой можно ознакомиться по [ссылке](https://radioprog.ru/post/1348)
## 6. Просмотр истории коммитов
После того, как вы создали несколько коммитов или же клонировали репозиторий с уже существующей историей коммитов, вероятно вам понадобится возможность посмотреть что было сделано — историю коммитов. Одним из основных и наиболее мощных инструментов для этого является команда ***`git log`***.

Следующие несколько примеров используют очень простой проект *«simplegit»*. Чтобы клонировать проект, используйте команду:
```C
$ git clone https://github.com/schacon/simplegit-progit
```
Если вы запустите команду `git log` в каталоге клонированного проекта, вы увидите следующий вывод:
```py
$ git log
commit ca82a6dff817ec66f44342007202690a93763949
Author: Scott Chacon <schacon@gee-mail.com>
Date:   Mon Mar 17 21:52:11 2008 -0700

    Change version number

commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
Author: Scott Chacon <schacon@gee-mail.com>
Date:   Sat Mar 15 16:40:33 2008 -0700

    Remove unnecessary test

commit a11bef06a3f659402fe7563abf99ad00de2209e6
Author: Scott Chacon <schacon@gee-mail.com>
Date:   Sat Mar 15 10:31:28 2008 -0700

    Initial commit
```
По умолчанию (без аргументов) `git log` перечисляет коммиты, сделанные в репозитории в обратном к хронологическому порядке — последние коммиты находятся вверху. Из примера можно увидеть, что данная команда перечисляет коммиты с их *SHA-1* контрольными суммами, именем и электронной почтой автора, датой создания и сообщением коммита.

Команда `git log` имеет очень большое количество опций для поиска коммитов по разным критериям. Рассмотрим наиболее популярные из них.

Одним из самых полезных аргументов является `-p` или `--patch`, который показывает разницу (выводит патч), внесённую в каждый коммит. Так же вы можете ограничить количество записей в выводе команды; используйте параметр `-2` для вывода только двух записей:
```py
$ git log -p -2
commit ca82a6dff817ec66f44342007202690a93763949
Author: Scott Chacon <schacon@gee-mail.com>
Date:   Mon Mar 17 21:52:11 2008 -0700

    Change version number

diff --git a/Rakefile b/Rakefile
index a874b73..8f94139 100644
--- a/Rakefile
+++ b/Rakefile
@@ -5,7 +5,7 @@ require 'rake/gempackagetask'
 spec = Gem::Specification.new do |s|
     s.platform  =   Gem::Platform::RUBY
     s.name      =   "simplegit"
-    s.version   =   "0.1.0"
+    s.version   =   "0.1.1"
     s.author    =   "Scott Chacon"
     s.email     =   "schacon@gee-mail.com"
     s.summary   =   "A simple gem for using Git in Ruby code."

commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
Author: Scott Chacon <schacon@gee-mail.com>
Date:   Sat Mar 15 16:40:33 2008 -0700

    Remove unnecessary test

diff --git a/lib/simplegit.rb b/lib/simplegit.rb
index a0a60ae..47c6340 100644
--- a/lib/simplegit.rb
+++ b/lib/simplegit.rb
@@ -18,8 +18,3 @@ class SimpleGit
     end

 end
-
-if $0 == __FILE__
-  git = SimpleGit.new
-  puts git.show
-end
```
Эта опция отображает аналогичную информацию но содержит разницу для каждой записи. Очень удобно использовать данную опцию для код ревью или для быстрого просмотра серии внесённых изменений. Так же есть возможность использовать серию опций для обобщения. Например, если вы хотите увидеть сокращённую статистику для каждого коммита, вы можете использовать опцию `--stat`:
```
$ git log --stat
commit ca82a6dff817ec66f44342007202690a93763949
Author: Scott Chacon <schacon@gee-mail.com>
Date:   Mon Mar 17 21:52:11 2008 -0700

    Change version number

 Rakefile | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
Author: Scott Chacon <schacon@gee-mail.com>
Date:   Sat Mar 15 16:40:33 2008 -0700

    Remove unnecessary test

 lib/simplegit.rb | 5 -----
 1 file changed, 5 deletions(-)

commit a11bef06a3f659402fe7563abf99ad00de2209e6
Author: Scott Chacon <schacon@gee-mail.com>
Date:   Sat Mar 15 10:31:28 2008 -0700

    Initial commit

 README           |  6 ++++++
 Rakefile         | 23 +++++++++++++++++++++++
 lib/simplegit.rb | 25 +++++++++++++++++++++++++
 3 files changed, 54 insertions(+)
```
Как вы видите, опция `--stat` печатает под каждым из коммитов список и количество изменённых файлов, а также сколько строк в каждом из файлов было добавлено и удалено. В конце можно увидеть суммарную таблицу изменений.

Следующей действительно полезной опцией является `--pretty`. Эта опция меняет формат вывода. Существует несколько встроенных вариантов отображения. Опция `oneline` выводит каждый коммит в одну строку, что может быть очень удобным если вы просматриваете большое количество коммитов. К тому же, опции `short`, `full` и `fuller` делают вывод приблизительно в том же формате, но с меньшим или большим количеством информации соответственно:
```py
$ git log --pretty=oneline
ca82a6dff817ec66f44342007202690a93763949 Change version number
085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 Remove unnecessary test
a11bef06a3f659402fe7563abf99ad00de2209e6 Initial commit
```
Наиболее интересной опцией является `format`, которая позволяет указать формат для вывода информации. Особенно это может быть полезным когда вы хотите сгенерировать вывод для автоматического анализа — так как вы указываете формат явно, он не будет изменен даже после обновления Git:
```
$ git log --pretty=format:"%h - %an, %ar : %s"
ca82a6d - Scott Chacon, 6 years ago : Change version number
085bb3b - Scott Chacon, 6 years ago : Remove unnecessary test
a11bef0 - Scott Chacon, 6 years ago : Initial commit
```
Полезные опции для `git log --pretty=format` отображает наиболее полезные опции для изменения формата.

### Таблица 1. Полезные опции для git log --pretty=format
| Опция | Описания вывода                                             |
|-------|-------------------------------------------------------------|
| %H    | Хеш коммита                                                 |
| %h    | Сокращённый хеш коммита                                     |
| %T    | Хеш дерева                                                  |
| %t    | Сокращённый хеш дерева                                      |
| %P    | Хеш родителей                                               |
| %p    | Сокращённый хеш родителей                                   |
| %an   | Имя автора                                                  |
| %ae   | Электронная почта автора                                    |
| %ad   | Дата автора (формат даты можно задать опцией --date=option) |
| %ar   | Относительная дата автора                                   |
| %cn   | Имя коммитера                                               |
| %ce   | Электронная почта коммитера                                 |
| %cd   | Дата коммитера                                              |
| %cr   | Относительная дата коммитера                                |
| %s    | Содержание                                                  |
## 7. Перемещение между сохранениями
Git позволяет не только просматривать историю. 
>Еще мы можем перемещаться по истории, загружая в рабочую директорию состояние кода на момент выполнения любого коммита. 

В этом уроке мы изучим, как перемещаться по истории с помощью команды `git checkout`.

Для начала воспользуемся командой `git log`:

### Показывает сокращенный вывод
```py
git log --oneline

fc74e2d update README.md
65a8ef7 Revert "remove PEOPLE.md"
5120bea add new content
e6f625c add INFO.md
273f81c remove NEW.md
aa600a4 remove PEOPLE.md
fe9893b add NEW.md
3ce3c02 add PEOPLE.md
3c5d976 add README.md
```
Переключимся на момент, когда был выполнен коммит с сообщением `add INFO.md`. Для этого используем команду `git checkout` <хеш коммита>:
```py
git checkout e6f625c

Note: switching to 'e6f625c'.

You are in 'detached HEAD' state. You can look around, make experimental
changes and commit them, and you can discard any commits you make in this
state without impacting any branches by switching back to a branch.

Or undo this operation with:

  git switch -
```
 Обратите внимание, что хеш вашего коммита может отличаться. Вы увидите, что пропала часть изменений из-за возврата в прошлое. Сами изменения никуда не делись, и мы снова можем вернуться на последний коммит следующей командой:
```py
git checkout main
```
Переключившись в нужный коммит, можно не только изучить содержимое репозитория. Еще мы можем забрать какие-то изменения, которые были удалены, но снова понадобились для работы. Для этого достаточно их скопировать, переключиться на последний коммит и вставить в нужный файл.

Команда `git branch`
Переключение по коммитам отражается только на содержимом рабочей директории. Больше нигде не видно, где мы находимся. Из-за этого немало программистов забывают, где они находятся. Они начинают работать и очень удивляются, когда не получается выполнить коммит.

Самый простой способ узнать место нахождения — вызвать команду `git branch`. В обычной ситуации, когда мы находимся на последнем коммите, Git покажет такой вывод:
```
git branch

main
```

## 8. Игнорирование файлов
Для того, чтобы исключить из отслеживания в репозитории определённые файлы или папки, необходимо создать файл 
```
.gitignore 
```
и записать в него название или шаблоны, соответствующие таким файлам или папкам.

## 9. Создание веток в Git
Создать ветку можно командой 
```
git branch <имя новой ветки>
```
Список веток в репозитории можно посмотреть с помощью команды 
```
git branch
```

Текущая ветка будет помечена звёздой:
 ```
  \* master
```
## 10. Слияние веток и разрещение конфликтов
 Для слияния выбранной ветки с текущей, требуется выполнить команду **_git merge <название выбранной ветки>_**

 Если была изменена одна и та же часть файла в обеих ветках, то может возникнуть конфликт, который потребет участия пользователя. VScode предлагает варианты разрешения конфликта.

## 11. Удаление веток

Чтобы удалить ветку в Git необходимо выполнить код **_git branch -d <наименование ветки>_**

Ветка, которую необходимо удалить, не должна быть текущей веткой, в которой проходит работа, иначе отобразится ошибка вида:
```
error: Cannot delete branch ’mybranch’ checked out at ’/path/to
```
Поэтому, если нужно удалить текущую ветку, то сначала нужно переключиться на какую-либо другую ветку, а только потом выполнять удаление.

Если вдруг возникает ошибка: 
```
The branch ’имя ветки’ is not fully merged. If you are sure you want to delete it 
и вы по прежнему хотите удалить ветку, то для принудительного удаления ветки можно воспользоваться опцией -D
```
**_git branch -D <имя ветки>_**

![Спасибо за внимание](/THNKS.png)